[["index.html", "Introducción a Ciencia de Datos y Machine Learning BIENVENIDA Objetivo Instructores Alcances del curso Duración y evaluación del curso Recursos y dinámica de clase", " Introducción a Ciencia de Datos y Machine Learning BIENVENIDA Objetivo Brindar al participante los elementos teóricos y prácticos básicos alrededor de la programación para el análisis de datos. Aprenderá a distinguir las diferentes soluciones a problemas que pueden resolverse con algoritmos de machine learning y aprenderá a usar el conjunto de librerías en R más novedosas, estructuradas y ampliamente usadas para la manipulación, transformación y visualización de datos: “TIDYVERSE”. Instructores ACT. ARTURO BRINGAS LinkedIn: arturo-bringas Email: act.arturo.b@ciencias.unam.mx Actuario egresado de la Facultad de Ciencias con maestría en Ciencia de Datos por el ITAM. Se especializa en modelos predictivos y de clasificación de machine learning aplicado a seguros, banca, marketing, deportes, e-commerce y movilidad internacional. Ha sido consultor Senior Data Scientist para empresas y organizaciones como GNP, El Universal, UNAM, la Organización de las Naciones Unidas Contra la Droga y el Delito (UNODC), entre otros. Actualmente es profesor de Ciencia de datos y Machine Learning en AMAT y Data Scientist Expert en BBVA, en donde implementa soluciones de analítica avanzada con impacto global. ACT. KARINA LIZETTE GAMBOA LinkedIn: KaLizzyGam Email: lizzygamboa@ciencias.unam.mx Actuaria egresada de la Facultad de Ciencias y candidata a Maestra en Ciencia de Datos por el ITAM. Experiencia en áreas de analítica predictiva e inteligencia del negocio. Lead y Senior Data Scientist en consultoría en diferentes sectores como tecnología, asegurador, financiero y bancario. Es experta en entendimiento de negocio para la correcta implementación de algoritmos de inteligencia y explotación de datos. Actualmente se desarrolla como lead data specialist en Merama, startup mexicana clasificada como uno de los nuevos unicornios de Latinoamérica. Senior Data Scientist en CLOSTER y como profesora del diplomado de Metodología de la Investigación Social por la UNAM así como instructora de cursos de Ciencia de Datos en AMAT. Empresas anteriores: GNP, Actinver Banco y Casa de Bolsa, PlayCity Casinos, RakenDataGroup Consulting, entre otros. Alcances del curso Al finalizar este curso, el participante será capaz de consumir, manipular y visualizar información para resolver problemas de propósito general asociados a los datos. Apenderá a implementar diferentes algoritmos de machine learning y mejorar su desempeño predictivo en problemas de clasificación, regresión y segmentación. Requisitos: Computadora con al menos 8Gb Ram Instalar la versión más reciente de R Instalar la versión más reciente de RStudio Temario: 1. Introducción a Ciencia de Datos Machine Learning, Bigdata, BI, AI y CD Objetivo de ciencia de datos Requisitos y aplicaciones Tipos de algoritmos Ciclo de vida de un proyecto 2. Manipulación de datos con Tidyverse Importación de tablas (readr) Consultas (dplyr) Transformación de estructuras (tidyr) 3. Concepto de Machine Learning Machine learning Análisis supervisado Análisis no supervisado Sesgo y varianza Partición de datos Preprocesamiento e ingeniería de datos 4. Algoritmos de Machine Learning Clustering: Kmeans, kmedoids, agnes Regresión Lineal Métricas de error Regresión logística Métricas de error KNN Árbol de decisión Random Forest Comparación de modelos Duración y evaluación del curso El programa tiene una duración de 40 hrs. Las clases serán impartidas los días sábado, de 9:00 am a 1:00 pm Serán asignados ejercicios que el participante deberá resolver entre una semana y otra. Al final del curso se solicitará un proyecto final, el cual deberá ser entregado para ser acreedor a la constancia de participación. Recursos y dinámica de clase En esta clase estaremos usando: R da click aquí si aún no lo descargas RStudio da click aquí también Zoom Clases Pulgar arriba: Voy bien, estoy entendiendo! Pulgar abajo: Eso no quedó muy claro Mano arriba: Quiero participar/preguntar ó Ya estoy listo para iniciar Google Drive Notas de clase Revisame si quieres aprender "],["conceptos-de-ciencia-de-datos.html", "Capítulo 1 Conceptos de Ciencia de Datos 1.1 ¿Qué es Ciencia de Datos? 1.2 Objetivos 1.3 Requisitos 1.4 Aplicaciones 1.5 Tipos de algoritmos 1.6 Ciclo de un proyecto", " Capítulo 1 Conceptos de Ciencia de Datos 1.1 ¿Qué es Ciencia de Datos? Definiendo conceptos: Estadística Disciplina que recolecta, organiza, analiza e interpreta datos. Lo hace a través de una población muestral generando estadística descriptiva y estadística inferencial. La estadística descriptiva, como su nombre lo indica, se encarga de describir datos y obtener conclusiones. Se utilizan números (media, mediana, moda, mínimo, máximo, etc) para analizar datos y llegar a conclusiones de acuerdo a ellos. La estadística inferencial argumenta o infiere sus resultados a partir de las muestras de una población. Se intenta conseguir información al utilizar un procedimiento ordenado en el manejo de los datos de la muestra. La estadística predictiva busca estimar valores y escenarios futuros más probables de ocurrir a partir de referencias históricas previas. Se suelen ocupar como apoyo características y factores áltamente asociados al fenómeno que se desea predecir. Business Intelligence: BI aprovecha el software y los servicios para transformar los datos en conocimientos prácticos que informan las decisiones empresariales estratégicas y tácticas de una organización. Las herramientas de BI acceden y analizan conjuntos de datos y presentan hallazgos analíticos en informes, resúmenes, tableros, gráficos, cuadros, -indicadores- o KPI’s y mapas para proporcionar a los usuarios inteligencia detallada sobre el estado del negocio. BI esta enfocado en analizar la historia pasada para tomar decisiones hacia el futuro. ¿Qué características tiene un KPI? Específicos Continuos y periódicos Objetivos Cuantificables Medibles Realistas Concisos Coherentes Relevantes Machine Learning: Machine learning –aprendizaje de máquina– es una rama de la inteligencia artificial que permite que las máquinas aprendan de los patrones existentes en los datos. Se usan métodos computacionales para aprender de datos con el fin de producir reglas para mejorar el desempeño en alguna tarea o toma de decisión. (Está enfocado en la programación de máquinas para aprender de los patrones existentes en datos principalmente estructurados y anticiparse al futuro) Deep Learning: El aprendizaje profundo es un subcampo del aprendizaje automático que se ocupa de los algoritmos inspirados en la estructura y función del cerebro llamados redes neuronales artificiales. En Deep Learning, un modelo de computadora aprende a realizar tareas de clasificación directamente a partir de imágenes, texto o sonido. Los modelos de aprendizaje profundo pueden lograr una precisión de vanguardia, a veces superando el rendimiento a nivel humano. Los modelos se entrenan mediante el uso de un gran conjunto de datos etiquetados y arquitecturas de redes neuronales que contienen muchas capas. (Está enfocado en la programación de máquinas para el reconocimiento de imágenes y audio (datos no estructurados)) Big data se refiere a los grandes y diversos conjuntos de información que crecen a un ritmo cada vez mayor. Abarca el volumen de información, la velocidad a la que se crea y recopila, y la variedad o alcance de los puntos de datos que se cubren. Los macrodatos a menudo provienen de la minería de datos y llegan en múltiples formatos. Es común que se confunda los conceptos de Big Data y Big Compute, como se mencionó, Big Data se refiere al procesamiento de conjuntos de datos que son más voluminosos y complejos que los tradicionales y Big Compute a herramientas y enfoques que utilizan una gran cantidad de recursos de CPU y memoria de forma coordinada para resolver problemas que usan algoritmos muy complejos. Curiosidad: Servidores en líquido para ser enfriados Curiosidad 2: Centro de datos en el océano Entonces, ¿qué NO es ciencia de datos? No es una tecnología No es una herramienta No es desarrollo de software No es Business Intelligence* No es Big Data* No es Inteligencia Artificial* No es (solo) machine learning No es (solo) deep learning No es (solo) visualización No es (solo) hacer modelos 1.2 Objetivos Los científicos de datos analizan qué preguntas necesitan respuesta y dónde encontrar los datos relacionados. Tienen conocimiento de negocio y habilidades analíticas, así como la capacidad de extraer, limpiar y presentar datos. Las empresas utilizan científicos de datos para obtener, administrar y analizar grandes cantidades de datos no estructurados. Luego, los resultados se sintetizan y comunican a las partes interesadas clave para impulsar la toma de decisiones estratégicas en la organización. Fuente: Blog post de Drew Conway Más sobre Conway: Forbes 2016 1.3 Requisitos Background científico: Conocimientos generales de probabilidad, estadística, álgebra lineal, cálculo, geometría analítica, programación, conocimientos computacionales… etc Datos relevantes y suficientes: Es indispensable saber si los datos con los que se trabajará son relevantes y suficientes, debemos evaluar qué preguntas podemos responder con los datos con los que contamos. Suficiencia: Los datos con los que trabajamos tienen que ser representativos de la población en general, necesitamos que las características representadas en la información sean suficientes para aproximar a la población objetivo. Relevancia: De igual manera los datos tienen que tener relevancia para la tarea que queremos resolver, por ejemplo, es probable que información sobre gusto en alimentos sea irrelevante para predecir número de hijos. Etiquetas: Se necesita la intervención humana para etiquetar, clasificar e introducir los datos en el algoritmo. Software: Existen distintos lenguajes de programación para realizar ciencia de datos 1.4 Aplicaciones Dependiendo de la industria en la que se quiera aplicar Machine Learning, podemos pensar en distintos enfoques, en la siguiente imagen se muestran algunos ejemplos: Podemos pensar en una infinidad de aplicaciones comerciales basadas en el análisis de datos. Con la intención de estructurar las posibles aplicaciones, se ofrece a continuación una categorización que, aunque no es suficiente para englobar todos los posibles casos de uso, sí es sorprendente la cantidad de aplicaciones que abarca. 1. Aplicaciones centradas en los clientes Incrementar beneficio al mejorar recomendaciones de productos Up-selling Cross-selling Reducir tasas de cancelación y mejorar tasas de retención Personalizar experiencia de usuario Mejorar el marketing dirigido Análisis de sentimientos Personalización de productos o servicios 2. Optimización de problemas Optimización de precios Ubicación de nuevas sucursales Maximización de ganancias mediante producción de materias primas Construcción de portafolios de inversión 3. Predicción de demanda Número futuro de clientes Número esperado de viajes en avión / camión / bicis Número de contagios por un virus (demanda médica / medicamentos / etc) Predicción de uso de recursos (luz / agua / gas) 4. Análisis de detección de fraudes Detección de robo de identidad Detección de transacciones ilícitas Detección de servicios fraudulentos Detección de zonas geográficas con actividades ilícitas 1.5 Tipos de algoritmos Los algoritmos de Machine Learning se dividen en tres categorías, siendo las dos primeras las más comunes: La diferencia entre el análisis supervisado y el no supervisado es la etiqueta, es decir, en el análisis supervisado tenemos una etiqueta “correcta” y el objetivo de los algoritmos es predecir esta etiqueta. 1.5.1 Aprendizaje supervisado En el aprendizaje supervisado, la idea principal es aprender bajo supervisión, donde la señal de supervisión se nombra como valor objetivo o etiqueta. Estos algoritmos cuentan con un aprendizaje previo basado en un sistema de etiquetas asociadas a unos datos que les permiten tomar decisiones o hacer predicciones. Conocemos la respuesta correcta de antemano. Esta respuesta correcta fue “etiquetada” por un humano (la mayoría de las veces, en algunas circunstancias puede ser generada por otro algoritmo). Debido a que conocemos la respuesta correcta, existen muchas métricas de desempeño del modelo para verificar que nuestro algoritmo está haciendo las cosas “bien”. Algunos ejemplos son: - Un detector de spam que etiqueta un e-mail como spam o no. - Predecir precios de casas - Clasificación de imagenes - Predecir el clima - ¿Quiénes son los clientes descontentos? Tipos de aprendizaje supervisado (Regresión vs clasificación) Existen dos tipos principales de aprendizaje supervisado, esto depende del tipo de la variable respuesta: Clasificación En el aprendizaje supervisado, los algoritmos de clasificación se usan cuando el resultado es una etiqueta discreta. Esto quiere decir que se utilizan cuando la respuesta se fundamenta en conjunto finito de resultados. Regresión El análisis de regresión es un subcampo del aprendizaje automático supervisado cuyo objetivo es establecer un método para la relación entre un cierto número de características y una variable objetivo continua. 1.5.2 Aprendizaje no supervisado En el aprendizaje no supervisado, carecemos de etiquetas. Por lo tanto, necesitamos encontrar nuestro camino sin ninguna supervisión ni guía. Esto simplemente significa que necesitamos descubrir ¿qué es qué? por nosotros mismos. Aquí no tenemos la respuesta correcta de antemano ¿cómo podemos saber que el algoritmo está bien o mal? Estadísticamente podemos verificar que el algoritmo está bien Siempre tenemos que verificar con el cliente si los resultados que estamos obteniendo tienen sentido de negocio. Por ejemplo, número de grupos y características Algunos ejemplos son: - Encontrar segmentos de clientes. - Reducir la complejidad de un problema - Selección de variables - Encontrar grupos - Reducción de dimensionalidad 1.5.3 Aprendizaje por refuerzo Su objetivo es que un algoritmo aprenda a partir de la propia experiencia. Esto es, que sea capaz de tomar la mejor decisión ante diferentes situaciones de acuerdo a un proceso de prueba y error en el que se recompensan las decisiones correctas. Algunos ejemplos son: - Optimización de campañas de marketing - Reconocimiento facial - Diagnósticos médicos - Clasificar secuencias de ADN Ejemplo: Mario Bros 1.6 Ciclo de un proyecto Identificación del problema Debemos conocer si el problema es significativo, si el problema se puede resolver con ciencia de datos, y si habrá un compromiso real del lado de cliente/usuario/partner para implementar la solución con todas sus implicaciones: recursos físicos y humanos. Scoping El objetivo es definir el alcance del proyecto y por lo tanto definir claramente los objetivos. Conocer las acciones que se llevarán a cabo para cada objetivo. Estas definirán las soluciones analíticas a hacer. Queremos saber si los datos con los que contamos son relevantes y suficientes. Hacer visible los posibles conflictos éticos que se pueden tener en esta fase. Debemos definir el cómo evaluaremos que el análisis de esos datos será balanceada entre eficiencia, efectividad y equidad. Adquisición de datos Adquisición, almacenamiento, entendimiento y preparación de los datos para después poder hacer analítica sober ellos. Asegurar que en la transferencia estamos cumpliendo con el manejo adecuado de datos sensibles y privados. EDA El objetivo en esta fase es conocer los datos con los que contamos y contexto de negocio explicado a través de los mismos. Identificamos datos faltantes, sugerimos cómo imputarlos. Altamente apoyado de visualización y procesos de adquisición y limpieza de datos. Formulación analítica Esta fase incluye empezar a formular nuestro problema como uno de ciencia de datos, el conocimiento adquirido en la fase de exploración nos permite conocer a mayor detalle del problema y por lo tanto de la solución adecuada. Modelado Proceso iterativo para desarrollar diferentes “experimentos”. Mismo algoritmo/método diferentes hiperparámetros (grid search). Diferentes algortimos. Selección de un muy pequeño conjunto de modelos tomando en cuenta un balance entre interpretabilidad, complejidad, desempeño, fairness. Correcta interpretación de los resultados de desempeño de cada modelo. Validación Es muy importante poner a prueba el/los modelo/modelos seleccionados en la fase anterior. Esta prueba es en campo con datos reales, le llamamos prueba piloto. Debemos medir el impacto causal que nuestro modelo tuvo en un ambiente real. Acciones a realizar Finalmente esta etapa corresponde a compartir con los tomadores de decisiones/stakeholders/creadores de política pública los resultados obtenidos y la recomendación de acciones a llevar a cabo -menú de opciones-. Las implicaciones éticas de esta fase consisten en hacer conciente el impacto social de nuestro trabajo. "],["introducción-a-r.html", "Capítulo 2 Introducción a R 2.1 ¿Cómo obtener R? 2.2 ¿Qué es RStudio? 2.3 Lectura de datos 2.4 Consultas de datos 2.5 Orden y estructura", " Capítulo 2 Introducción a R R (R Core Team) es un entorno y lenguaje de programación que permite el análisis estadístico de información y reportes gráficos. Es ampliamente usado en investigación por la comunidad estadística en campos como la biomedicina, minería de datos, matemáticas financieras, entre otros. Ha ganado mucha popularidad en los últimos años al ser un software libre que está en constante crecimiento por las aportaciones de otros usuarios y que permite la interacción con software estadísticos como STATA, SAS, SPSS, etc.. R permite la incorporación de librerías y paqueterías con funcionalidades específicas, por lo que es un lenguaje de programación muy completo y fácil de usar. 2.1 ¿Cómo obtener R? R puede ser fácilmente descargado de forma gratuita desde el sitio oficial http://www.r-project.org/. R está disponible para las plataformas Windows, Mac y Linux. 2.2 ¿Qué es RStudio? RStudio es un Entorno de Desarrollo Integrado (IDE, por sus siglas en inglés) para R. Este permite y facilita el desarrollo y ejecución de sintaxis para código en R, incluye una consola y proporciona herramientas para la gestión del espacio de trabajo. RStudio está disponible para Windows, Mac y Linux o para navegadores conectados a RStudio Server o RStudio Server Pro. Algunas de las principales características de Rstudio que lo hacen una gran herramienta para trabajar en R, son: Auto completado de código Sangría inteligente Resaltado de sintaxis Facilidad para definir funciones Soporte integrado Documentación integrada Administración de directorios y proyectos Visor de datos Depurador interactivo para corregir errores Conección con Rmarkwon y Sweave La siguiente imagen muestra la forma en la que está estructurado RStudio. El orden de los páneles puede ser elegido por el usuario, así como las características de tipo de letra, tamaño y color de fondo, entre otras características. Figure 2.1: Páneles de trabajo de Rstudio 2.3 Lectura de datos El primer paso para analizar datos es incorporarlos a la sesión de R para que puedan ser manipulados y observados. Existen múltiples librerías y funciones en R que permiten leer la información proveniente de un archivo externo, el cual puede tener una de muchas posibles extensiones. Usualmente, no creamos los datos desde la sesión de R, sino que a través de un archivo externo se realiza la lectura de datos escritos en un archivo. Los más comúnes son: La paquetería readr fue desarrollada recientemente para lidiar con la lectura de archivos grandes rápidamente. Esta paquetería proporciona funciones que suelen ser mucho más rápidas que las funciones base que proporciona R. Ventajas de readr: Por lo general, son mucho más rápidos (~ 10x) que sus funciones equivalentes. Producen tibbles: No convierten vectores de caracteres en factores. No usan nombres de filas ni modifican los nombres de columnas. Reproducibilidad 2.3.1 Archivos csv A la hora de importar conjuntos de datos en R, uno de los formatos más habituales en los que hallamos información es en archivos separados por comas (comma separated values), cuya extensión suele ser .csv. En ellos encontramos múltiples líneas que recogen la tabla de interés, y en las cuales los valores aparecen, de manera consecutiva, separados por el carácter ,. Para importar este tipo de archivos en nuestra sesión de R, se utiliza la función read_csv(). Para acceder a su documentación utilizamos el comando ?read_csv. El único argumento que debemos de pasar a esta función de manera obligatoria, es file, el nombre o la ruta completa del archivo que pretendemos importar. library(readr) read_csv( file, col_names = TRUE, col_types = NULL, locale = default_locale(), na = c(&quot;&quot;, &quot;NA&quot;), quoted_na = TRUE, quote = &quot;\\&quot;&quot;, comment = &quot;&quot;) La paquetería readr fue desarrollada recientemente para lidiar con la lectura de archivos grandes rápidamente. El paquete proporciona reemplazos para funciones como read.table(), read.csv() entre otras. Esta paquetería proporciona funciones que suelen ser mucho más rápidas que las funciones base que proporciona R. Ventajas de readr: Por lo general, son mucho más rápidos (~ 10x) que sus funciones equivalentes. Producen tibbles: No convierten vectores de caracteres en factores. No usan nombres de filas ni modifican los nombres de columnas. Reproducibilidad No convierte, automáticamente, las columnas con cadenas de caracteres a factores, como sí hacen por defecto las otras funciones base de R. Reconoce ocho clases diferentes de datos (enteros, lógicos, etc.), dejando el resto como cadenas de caracteres. Veamos un ejemplo: La base de datos llamada AmesHousing contiene un conjunto de datos con información de la Oficina del Tasador de Ames utilizada para calcular los valores tasados para las propiedades residenciales individuales vendidas en Ames, Iowa, de 2006 a 2010. FUENTES: Ames, Oficina del Tasador de Iowa. Pueden descargar los datos para la clase aquí base &lt;- read.csv(&quot;data/ames.csv&quot;) head(base, 2) ## MS_SubClass MS_Zoning Lot_Frontage ## 1 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 141 ## 2 One_Story_1946_and_Newer_All_Styles Residential_High_Density 80 ## Lot_Area Street Alley Lot_Shape Land_Contour Utilities ## 1 31770 Pave No_Alley_Access Slightly_Irregular Lvl AllPub ## 2 11622 Pave No_Alley_Access Regular Lvl AllPub ## Lot_Config Land_Slope Neighborhood Condition_1 Condition_2 Bldg_Type ## 1 Corner Gtl North_Ames Norm Norm OneFam ## 2 Inside Gtl North_Ames Feedr Norm OneFam ## House_Style Overall_Cond Year_Built Year_Remod_Add Roof_Style Roof_Matl ## 1 One_Story Average 1960 1960 Hip CompShg ## 2 One_Story Above_Average 1961 1961 Gable CompShg ## Exterior_1st Exterior_2nd Mas_Vnr_Type Mas_Vnr_Area Exter_Cond Foundation ## 1 BrkFace Plywood Stone 112 Typical CBlock ## 2 VinylSd VinylSd None 0 Typical CBlock ## Bsmt_Cond Bsmt_Exposure BsmtFin_Type_1 BsmtFin_SF_1 BsmtFin_Type_2 ## 1 Good Gd BLQ 2 Unf ## 2 Typical No Rec 6 LwQ ## BsmtFin_SF_2 Bsmt_Unf_SF Total_Bsmt_SF Heating Heating_QC Central_Air ## 1 0 441 1080 GasA Fair Y ## 2 144 270 882 GasA Typical Y ## Electrical First_Flr_SF Second_Flr_SF Gr_Liv_Area Bsmt_Full_Bath ## 1 SBrkr 1656 0 1656 1 ## 2 SBrkr 896 0 896 0 ## Bsmt_Half_Bath Full_Bath Half_Bath Bedroom_AbvGr Kitchen_AbvGr TotRms_AbvGrd ## 1 0 1 0 3 1 7 ## 2 0 1 0 2 1 5 ## Functional Fireplaces Garage_Type Garage_Finish Garage_Cars Garage_Area ## 1 Typ 2 Attchd Fin 2 528 ## 2 Typ 0 Attchd Unf 1 730 ## Garage_Cond Paved_Drive Wood_Deck_SF Open_Porch_SF Enclosed_Porch ## 1 Typical Partial_Pavement 210 62 0 ## 2 Typical Paved 140 0 0 ## Three_season_porch Screen_Porch Pool_Area Pool_QC Fence ## 1 0 0 0 No_Pool No_Fence ## 2 0 120 0 No_Pool Minimum_Privacy ## Misc_Feature Misc_Val Mo_Sold Year_Sold Sale_Type Sale_Condition Sale_Price ## 1 None 0 5 2010 WD Normal 215000 ## 2 None 0 6 2010 WD Normal 105000 ## Longitude Latitude ## 1 -93.61975 42.05403 ## 2 -93.61976 42.05301 tidy &lt;- read_csv(&quot;data/ames.csv&quot;) head(tidy, 2) ## # A tibble: 2 × 74 ## MS_SubC…¹ MS_Zo…² Lot_F…³ Lot_A…⁴ Street Alley Lot_S…⁵ Land_…⁶ Utili…⁷ Lot_C…⁸ ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 One_Stor… Reside… 141 31770 Pave No_A… Slight… Lvl AllPub Corner ## 2 One_Stor… Reside… 80 11622 Pave No_A… Regular Lvl AllPub Inside ## # … with 64 more variables: Land_Slope &lt;chr&gt;, Neighborhood &lt;chr&gt;, ## # Condition_1 &lt;chr&gt;, Condition_2 &lt;chr&gt;, Bldg_Type &lt;chr&gt;, House_Style &lt;chr&gt;, ## # Overall_Cond &lt;chr&gt;, Year_Built &lt;dbl&gt;, Year_Remod_Add &lt;dbl&gt;, ## # Roof_Style &lt;chr&gt;, Roof_Matl &lt;chr&gt;, Exterior_1st &lt;chr&gt;, Exterior_2nd &lt;chr&gt;, ## # Mas_Vnr_Type &lt;chr&gt;, Mas_Vnr_Area &lt;dbl&gt;, Exter_Cond &lt;chr&gt;, Foundation &lt;chr&gt;, ## # Bsmt_Cond &lt;chr&gt;, Bsmt_Exposure &lt;chr&gt;, BsmtFin_Type_1 &lt;chr&gt;, ## # BsmtFin_SF_1 &lt;dbl&gt;, BsmtFin_Type_2 &lt;chr&gt;, BsmtFin_SF_2 &lt;dbl&gt;, … ¿Y si el archivo que necesitamos leer esta en excel? 2.3.2 Archivos txt Uno de los archivos más comunes es el .txt. La librería readr también cuenta con funciones que permiten leer fácilmente los datos contenidos en formato tabular. ames_txt &lt;- read_delim(&quot;data/ames.txt&quot;, delim = &quot;;&quot;, col_names = TRUE) head(ames_txt, 2) ## # A tibble: 2 × 74 ## MS_SubC…¹ MS_Zo…² Lot_F…³ Lot_A…⁴ Street Alley Lot_S…⁵ Land_…⁶ Utili…⁷ Lot_C…⁸ ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 One_Stor… Reside… 141 31770 Pave No_A… Slight… Lvl AllPub Corner ## 2 One_Stor… Reside… 80 11622 Pave No_A… Regular Lvl AllPub Inside ## # … with 64 more variables: Land_Slope &lt;chr&gt;, Neighborhood &lt;chr&gt;, ## # Condition_1 &lt;chr&gt;, Condition_2 &lt;chr&gt;, Bldg_Type &lt;chr&gt;, House_Style &lt;chr&gt;, ## # Overall_Cond &lt;chr&gt;, Year_Built &lt;dbl&gt;, Year_Remod_Add &lt;dbl&gt;, ## # Roof_Style &lt;chr&gt;, Roof_Matl &lt;chr&gt;, Exterior_1st &lt;chr&gt;, Exterior_2nd &lt;chr&gt;, ## # Mas_Vnr_Type &lt;chr&gt;, Mas_Vnr_Area &lt;dbl&gt;, Exter_Cond &lt;chr&gt;, Foundation &lt;chr&gt;, ## # Bsmt_Cond &lt;chr&gt;, Bsmt_Exposure &lt;chr&gt;, BsmtFin_Type_1 &lt;chr&gt;, ## # BsmtFin_SF_1 &lt;dbl&gt;, BsmtFin_Type_2 &lt;chr&gt;, BsmtFin_SF_2 &lt;dbl&gt;, … La función read_delim() funciona para leer archivos con diferentes delimitadores posibles, es decir, es posible especificar si las columnas están separadas por espacios, comas, punto y coma, tabulador o algún otro delimitador (““,”,“,”;“,”, “@”). Adicionalmente, se puede especificar si el archivo contiene encabezado, si existen renglones a saltar, codificación, tipo de variable y muchas más opciones. Todos estos detalles pueden consultarse en la documentación de ayuda. 2.3.3 Archivos xls y xlsx La paquetería readxl facilita la obtención de datos tabulares de archivos de Excel. Admite tanto el formato .xls heredado como el formato .xlsx moderno basado en XML. Esta paquetería pone a disposición las siguientes funciones: read_xlsx() lee un archivo con extensión xlsx. read_xlsx( path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = &quot;unique&quot; ) read_xls() lee un archivo con extensión xls. read_xls( path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = &quot;unique&quot; ) read_excel() determina si el archivo es de tipo xls o xlsx para después llamar a una de las funciones mencionadas anteriormente. read_excel( path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = &quot;&quot;, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = &quot;unique&quot; ) EJERCICIO: Leer archivo excel de la carpeta del curso 2.3.4 Archivos json Se utiliza la función fromJSON de la paquetería jsonlite library(jsonlite) base_json &lt;- jsonlite::fromJSON(&quot;data/ames.json&quot;) head(base_json, 2) ## MS_SubClass MS_Zoning Lot_Frontage ## 1 One_Story_1946_and_Newer_All_Styles Residential_Low_Density 141 ## 2 One_Story_1946_and_Newer_All_Styles Residential_High_Density 80 ## Lot_Area Street Alley Lot_Shape Land_Contour Utilities ## 1 31770 Pave No_Alley_Access Slightly_Irregular Lvl AllPub ## 2 11622 Pave No_Alley_Access Regular Lvl AllPub ## Lot_Config Land_Slope Neighborhood Condition_1 Condition_2 Bldg_Type ## 1 Corner Gtl North_Ames Norm Norm OneFam ## 2 Inside Gtl North_Ames Feedr Norm OneFam ## House_Style Overall_Cond Year_Built Year_Remod_Add Roof_Style Roof_Matl ## 1 One_Story Average 1960 1960 Hip CompShg ## 2 One_Story Above_Average 1961 1961 Gable CompShg ## Exterior_1st Exterior_2nd Mas_Vnr_Type Mas_Vnr_Area Exter_Cond Foundation ## 1 BrkFace Plywood Stone 112 Typical CBlock ## 2 VinylSd VinylSd None 0 Typical CBlock ## Bsmt_Cond Bsmt_Exposure BsmtFin_Type_1 BsmtFin_SF_1 BsmtFin_Type_2 ## 1 Good Gd BLQ 2 Unf ## 2 Typical No Rec 6 LwQ ## BsmtFin_SF_2 Bsmt_Unf_SF Total_Bsmt_SF Heating Heating_QC Central_Air ## 1 0 441 1080 GasA Fair Y ## 2 144 270 882 GasA Typical Y ## Electrical First_Flr_SF Second_Flr_SF Gr_Liv_Area Bsmt_Full_Bath ## 1 SBrkr 1656 0 1656 1 ## 2 SBrkr 896 0 896 0 ## Bsmt_Half_Bath Full_Bath Half_Bath Bedroom_AbvGr Kitchen_AbvGr TotRms_AbvGrd ## 1 0 1 0 3 1 7 ## 2 0 1 0 2 1 5 ## Functional Fireplaces Garage_Type Garage_Finish Garage_Cars Garage_Area ## 1 Typ 2 Attchd Fin 2 528 ## 2 Typ 0 Attchd Unf 1 730 ## Garage_Cond Paved_Drive Wood_Deck_SF Open_Porch_SF Enclosed_Porch ## 1 Typical Partial_Pavement 210 62 0 ## 2 Typical Paved 140 0 0 ## Three_season_porch Screen_Porch Pool_Area Pool_QC Fence ## 1 0 0 0 No_Pool No_Fence ## 2 0 120 0 No_Pool Minimum_Privacy ## Misc_Feature Misc_Val Mo_Sold Year_Sold Sale_Type Sale_Condition Sale_Price ## 1 None 0 5 2010 WD Normal 215000 ## 2 None 0 6 2010 WD Normal 105000 ## Longitude Latitude ## 1 -93.6198 42.054 ## 2 -93.6198 42.053 2.3.5 Archivos rds Un tipo de archivo que resulta de particular interés, es el .RDS. Este archivo comprime cualquier objeto o resultado que sea usado o producido en R. Uno puede almacenar el objeto de interés de la siguiente manera: saveRDS(base_json, &quot;data/ames.rds&quot;) Puede observarse que en el explorador de archivos se encuentra ahora el nuevo archivo con extensión .rds, el cual puede ser posteriormente incorporado a una sesión de R para seguir trabajando con él. base_rds &lt;- readRDS(&quot;data/ames.rds&quot;) Algunas de las grandes ventajas que tiene almacenar los archivos en formato rds, son las siguientes: No es necesario volver a ejecutar procesos largos cuando ya se ha logrado realizar una vez. El tiempo de lectura de la información es considerablemente más rápido. 2.4 Consultas de datos Ahora que ya se ha estudiado la manera de cargar datos, aprenderemos como manipularlos con dplyr. El paquete dplyr proporciona un conjunto de funciones muy útiles para manipular data-frames y así reducir el número de repeticiones, la probabilidad de cometer errores y el número de caracteres que hay que escribir. Como valor extra, podemos encontrar que la gramática de dplyr es más fácil de entender. Revisaremos algunas de sus funciones más usadas (verbos), así como el uso de pipes (%&gt;%) para combinarlas. select() filter() arrange() mutate() summarise() join() group_by() Primero tenemos que instalar y cargar la paquetería (parte de tidyverse): # install.packages(&quot;dplyr&quot;) library(dplyr) library(readr) Usaremos el dataset AmesHousing que se proporcionó en el capítulo anterior (el alumno puede hacer el ejercicio con datos propios) ames_housing &lt;- read_csv(&quot;data/ames.csv&quot;) glimpse(ames_housing) ## Rows: 2,930 ## Columns: 74 ## $ MS_SubClass &lt;chr&gt; &quot;One_Story_1946_and_Newer_All_Styles&quot;, &quot;One_Story_1… ## $ MS_Zoning &lt;chr&gt; &quot;Residential_Low_Density&quot;, &quot;Residential_High_Densit… ## $ Lot_Frontage &lt;dbl&gt; 141, 80, 81, 93, 74, 78, 41, 43, 39, 60, 75, 0, 63,… ## $ Lot_Area &lt;dbl&gt; 31770, 11622, 14267, 11160, 13830, 9978, 4920, 5005… ## $ Street &lt;chr&gt; &quot;Pave&quot;, &quot;Pave&quot;, &quot;Pave&quot;, &quot;Pave&quot;, &quot;Pave&quot;, &quot;Pave&quot;, &quot;Pa… ## $ Alley &lt;chr&gt; &quot;No_Alley_Access&quot;, &quot;No_Alley_Access&quot;, &quot;No_Alley_Acc… ## $ Lot_Shape &lt;chr&gt; &quot;Slightly_Irregular&quot;, &quot;Regular&quot;, &quot;Slightly_Irregula… ## $ Land_Contour &lt;chr&gt; &quot;Lvl&quot;, &quot;Lvl&quot;, &quot;Lvl&quot;, &quot;Lvl&quot;, &quot;Lvl&quot;, &quot;Lvl&quot;, &quot;Lvl&quot;, &quot;H… ## $ Utilities &lt;chr&gt; &quot;AllPub&quot;, &quot;AllPub&quot;, &quot;AllPub&quot;, &quot;AllPub&quot;, &quot;AllPub&quot;, &quot;… ## $ Lot_Config &lt;chr&gt; &quot;Corner&quot;, &quot;Inside&quot;, &quot;Corner&quot;, &quot;Corner&quot;, &quot;Inside&quot;, &quot;… ## $ Land_Slope &lt;chr&gt; &quot;Gtl&quot;, &quot;Gtl&quot;, &quot;Gtl&quot;, &quot;Gtl&quot;, &quot;Gtl&quot;, &quot;Gtl&quot;, &quot;Gtl&quot;, &quot;G… ## $ Neighborhood &lt;chr&gt; &quot;North_Ames&quot;, &quot;North_Ames&quot;, &quot;North_Ames&quot;, &quot;North_Am… ## $ Condition_1 &lt;chr&gt; &quot;Norm&quot;, &quot;Feedr&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;N… ## $ Condition_2 &lt;chr&gt; &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;No… ## $ Bldg_Type &lt;chr&gt; &quot;OneFam&quot;, &quot;OneFam&quot;, &quot;OneFam&quot;, &quot;OneFam&quot;, &quot;OneFam&quot;, &quot;… ## $ House_Style &lt;chr&gt; &quot;One_Story&quot;, &quot;One_Story&quot;, &quot;One_Story&quot;, &quot;One_Story&quot;,… ## $ Overall_Cond &lt;chr&gt; &quot;Average&quot;, &quot;Above_Average&quot;, &quot;Above_Average&quot;, &quot;Avera… ## $ Year_Built &lt;dbl&gt; 1960, 1961, 1958, 1968, 1997, 1998, 2001, 1992, 199… ## $ Year_Remod_Add &lt;dbl&gt; 1960, 1961, 1958, 1968, 1998, 1998, 2001, 1992, 199… ## $ Roof_Style &lt;chr&gt; &quot;Hip&quot;, &quot;Gable&quot;, &quot;Hip&quot;, &quot;Hip&quot;, &quot;Gable&quot;, &quot;Gable&quot;, &quot;Ga… ## $ Roof_Matl &lt;chr&gt; &quot;CompShg&quot;, &quot;CompShg&quot;, &quot;CompShg&quot;, &quot;CompShg&quot;, &quot;CompSh… ## $ Exterior_1st &lt;chr&gt; &quot;BrkFace&quot;, &quot;VinylSd&quot;, &quot;Wd Sdng&quot;, &quot;BrkFace&quot;, &quot;VinylS… ## $ Exterior_2nd &lt;chr&gt; &quot;Plywood&quot;, &quot;VinylSd&quot;, &quot;Wd Sdng&quot;, &quot;BrkFace&quot;, &quot;VinylS… ## $ Mas_Vnr_Type &lt;chr&gt; &quot;Stone&quot;, &quot;None&quot;, &quot;BrkFace&quot;, &quot;None&quot;, &quot;None&quot;, &quot;BrkFac… ## $ Mas_Vnr_Area &lt;dbl&gt; 112, 0, 108, 0, 0, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6… ## $ Exter_Cond &lt;chr&gt; &quot;Typical&quot;, &quot;Typical&quot;, &quot;Typical&quot;, &quot;Typical&quot;, &quot;Typica… ## $ Foundation &lt;chr&gt; &quot;CBlock&quot;, &quot;CBlock&quot;, &quot;CBlock&quot;, &quot;CBlock&quot;, &quot;PConc&quot;, &quot;P… ## $ Bsmt_Cond &lt;chr&gt; &quot;Good&quot;, &quot;Typical&quot;, &quot;Typical&quot;, &quot;Typical&quot;, &quot;Typical&quot;,… ## $ Bsmt_Exposure &lt;chr&gt; &quot;Gd&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Mn&quot;, &quot;No&quot;, &quot;No… ## $ BsmtFin_Type_1 &lt;chr&gt; &quot;BLQ&quot;, &quot;Rec&quot;, &quot;ALQ&quot;, &quot;ALQ&quot;, &quot;GLQ&quot;, &quot;GLQ&quot;, &quot;GLQ&quot;, &quot;A… ## $ BsmtFin_SF_1 &lt;dbl&gt; 2, 6, 1, 1, 3, 3, 3, 1, 3, 7, 7, 1, 7, 3, 3, 1, 3, … ## $ BsmtFin_Type_2 &lt;chr&gt; &quot;Unf&quot;, &quot;LwQ&quot;, &quot;Unf&quot;, &quot;Unf&quot;, &quot;Unf&quot;, &quot;Unf&quot;, &quot;Unf&quot;, &quot;U… ## $ BsmtFin_SF_2 &lt;dbl&gt; 0, 144, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1120, 0… ## $ Bsmt_Unf_SF &lt;dbl&gt; 441, 270, 406, 1045, 137, 324, 722, 1017, 415, 994,… ## $ Total_Bsmt_SF &lt;dbl&gt; 1080, 882, 1329, 2110, 928, 926, 1338, 1280, 1595, … ## $ Heating &lt;chr&gt; &quot;GasA&quot;, &quot;GasA&quot;, &quot;GasA&quot;, &quot;GasA&quot;, &quot;GasA&quot;, &quot;GasA&quot;, &quot;Ga… ## $ Heating_QC &lt;chr&gt; &quot;Fair&quot;, &quot;Typical&quot;, &quot;Typical&quot;, &quot;Excellent&quot;, &quot;Good&quot;, … ## $ Central_Air &lt;chr&gt; &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;… ## $ Electrical &lt;chr&gt; &quot;SBrkr&quot;, &quot;SBrkr&quot;, &quot;SBrkr&quot;, &quot;SBrkr&quot;, &quot;SBrkr&quot;, &quot;SBrkr… ## $ First_Flr_SF &lt;dbl&gt; 1656, 896, 1329, 2110, 928, 926, 1338, 1280, 1616, … ## $ Second_Flr_SF &lt;dbl&gt; 0, 0, 0, 0, 701, 678, 0, 0, 0, 776, 892, 0, 676, 0,… ## $ Gr_Liv_Area &lt;dbl&gt; 1656, 896, 1329, 2110, 1629, 1604, 1338, 1280, 1616… ## $ Bsmt_Full_Bath &lt;dbl&gt; 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, … ## $ Bsmt_Half_Bath &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ Full_Bath &lt;dbl&gt; 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 3, 2, … ## $ Half_Bath &lt;dbl&gt; 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, … ## $ Bedroom_AbvGr &lt;dbl&gt; 3, 2, 3, 3, 3, 3, 2, 2, 2, 3, 3, 3, 3, 2, 1, 4, 4, … ## $ Kitchen_AbvGr &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, … ## $ TotRms_AbvGrd &lt;dbl&gt; 7, 5, 6, 8, 6, 7, 6, 5, 5, 7, 7, 6, 7, 5, 4, 12, 8,… ## $ Functional &lt;chr&gt; &quot;Typ&quot;, &quot;Typ&quot;, &quot;Typ&quot;, &quot;Typ&quot;, &quot;Typ&quot;, &quot;Typ&quot;, &quot;Typ&quot;, &quot;T… ## $ Fireplaces &lt;dbl&gt; 2, 0, 0, 2, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, … ## $ Garage_Type &lt;chr&gt; &quot;Attchd&quot;, &quot;Attchd&quot;, &quot;Attchd&quot;, &quot;Attchd&quot;, &quot;Attchd&quot;, &quot;… ## $ Garage_Finish &lt;chr&gt; &quot;Fin&quot;, &quot;Unf&quot;, &quot;Unf&quot;, &quot;Fin&quot;, &quot;Fin&quot;, &quot;Fin&quot;, &quot;Fin&quot;, &quot;R… ## $ Garage_Cars &lt;dbl&gt; 2, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 2, … ## $ Garage_Area &lt;dbl&gt; 528, 730, 312, 522, 482, 470, 582, 506, 608, 442, 4… ## $ Garage_Cond &lt;chr&gt; &quot;Typical&quot;, &quot;Typical&quot;, &quot;Typical&quot;, &quot;Typical&quot;, &quot;Typica… ## $ Paved_Drive &lt;chr&gt; &quot;Partial_Pavement&quot;, &quot;Paved&quot;, &quot;Paved&quot;, &quot;Paved&quot;, &quot;Pav… ## $ Wood_Deck_SF &lt;dbl&gt; 210, 140, 393, 0, 212, 360, 0, 0, 237, 140, 157, 48… ## $ Open_Porch_SF &lt;dbl&gt; 62, 0, 36, 0, 34, 36, 0, 82, 152, 60, 84, 21, 75, 0… ## $ Enclosed_Porch &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ Three_season_porch &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ Screen_Porch &lt;dbl&gt; 0, 120, 0, 0, 0, 0, 0, 144, 0, 0, 0, 0, 0, 0, 140, … ## $ Pool_Area &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, … ## $ Pool_QC &lt;chr&gt; &quot;No_Pool&quot;, &quot;No_Pool&quot;, &quot;No_Pool&quot;, &quot;No_Pool&quot;, &quot;No_Poo… ## $ Fence &lt;chr&gt; &quot;No_Fence&quot;, &quot;Minimum_Privacy&quot;, &quot;No_Fence&quot;, &quot;No_Fenc… ## $ Misc_Feature &lt;chr&gt; &quot;None&quot;, &quot;None&quot;, &quot;Gar2&quot;, &quot;None&quot;, &quot;None&quot;, &quot;None&quot;, &quot;No… ## $ Misc_Val &lt;dbl&gt; 0, 0, 12500, 0, 0, 0, 0, 0, 0, 0, 0, 500, 0, 0, 0, … ## $ Mo_Sold &lt;dbl&gt; 5, 6, 6, 4, 3, 6, 4, 1, 3, 6, 4, 3, 5, 2, 6, 6, 6, … ## $ Year_Sold &lt;dbl&gt; 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 201… ## $ Sale_Type &lt;chr&gt; &quot;WD&quot;, &quot;WD&quot;, &quot;WD&quot;, &quot;WD&quot;, &quot;WD&quot;, &quot;WD&quot;, &quot;WD&quot;, &quot;WD&quot;, &quot;WD… ## $ Sale_Condition &lt;chr&gt; &quot;Normal&quot;, &quot;Normal&quot;, &quot;Normal&quot;, &quot;Normal&quot;, &quot;Normal&quot;, &quot;… ## $ Sale_Price &lt;dbl&gt; 215000, 105000, 172000, 244000, 189900, 195500, 213… ## $ Longitude &lt;dbl&gt; -93.61975, -93.61976, -93.61939, -93.61732, -93.638… ## $ Latitude &lt;dbl&gt; 42.05403, 42.05301, 42.05266, 42.05125, 42.06090, 4… 2.4.1 Seleccionar columnas Observamos que nuestros datos tienen 2,930 observaciones y 74 variables, con select() podemos seleccionar las variables que se indiquen. ames_housing %&gt;% select(Lot_Area, Neighborhood, Year_Sold, Sale_Price) ## # A tibble: 2,930 × 4 ## Lot_Area Neighborhood Year_Sold Sale_Price ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 31770 North_Ames 2010 215000 ## 2 11622 North_Ames 2010 105000 ## 3 14267 North_Ames 2010 172000 ## 4 11160 North_Ames 2010 244000 ## 5 13830 Gilbert 2010 189900 ## 6 9978 Gilbert 2010 195500 ## 7 4920 Stone_Brook 2010 213500 ## 8 5005 Stone_Brook 2010 191500 ## 9 5389 Stone_Brook 2010 236500 ## 10 7500 Gilbert 2010 189000 ## # … with 2,920 more rows ¡¡ RECORDAR !! El operador pipe (%&gt;%) se usa para conectar un elemento con una función o acción a realizar. En este caso solo se indica que en los datos de ames se seleccionan 4 variables. Con select() y contains() podemos seleccionar variables con alguna cadena de texto. ames_housing %&gt;% select(contains(&quot;Area&quot;)) ## # A tibble: 2,930 × 5 ## Lot_Area Mas_Vnr_Area Gr_Liv_Area Garage_Area Pool_Area ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 31770 112 1656 528 0 ## 2 11622 0 896 730 0 ## 3 14267 108 1329 312 0 ## 4 11160 0 2110 522 0 ## 5 13830 0 1629 482 0 ## 6 9978 20 1604 470 0 ## 7 4920 0 1338 582 0 ## 8 5005 0 1280 506 0 ## 9 5389 0 1616 608 0 ## 10 7500 0 1804 442 0 ## # … with 2,920 more rows De igual manera, con select(), ends_with y start_with() podemos seleccionar que inicien o terminen con alguna cadena de texto. ames_housing %&gt;% select(starts_with(&quot;Garage&quot;)) ## # A tibble: 2,930 × 5 ## Garage_Type Garage_Finish Garage_Cars Garage_Area Garage_Cond ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Attchd Fin 2 528 Typical ## 2 Attchd Unf 1 730 Typical ## 3 Attchd Unf 1 312 Typical ## 4 Attchd Fin 2 522 Typical ## 5 Attchd Fin 2 482 Typical ## 6 Attchd Fin 2 470 Typical ## 7 Attchd Fin 2 582 Typical ## 8 Attchd RFn 2 506 Typical ## 9 Attchd RFn 2 608 Typical ## 10 Attchd Fin 2 442 Typical ## # … with 2,920 more rows Funciones útiles para select(): contains(): Selecciona variables cuyo nombre contiene la cadena de texto. ends_with(): Selecciona variables cuyo nombre termina con la cadena de caracteres. everything(): Selecciona todas las columnas. matches(): Selecciona las variables cuyos nombres coinciden con una expresión regular. num_range(): Selecciona las variables por posición. start_with(): Selecciona variables cuyos nombres empiezan con la cadena de caracteres. any_of: Selecciona cualquiera de estas variables, en caso de existir EJERCICIO: Crear con datos propios una consulta de columnas usando como variable auxiliar cada una de las listadas anteriormente. Será suficiente con realizar un ejemplo de cada una. 2.4.2 Filtrar observaciones La función filter() nos permite filtrar filas según una condición, primero notemos que la variable Sale_Condition tiene distintas categorías. table(ames_housing$Sale_Condition) ## ## Abnorml AdjLand Alloca Family Normal Partial ## 190 12 24 46 2413 245 ¡¡ SPOILER !! En un modelo predictivo de Machine Learning, no es correcto agregar columnas cuyo valor es conocido hasta el momento de la observación. Es decir, no deben agregarse variables que no se conozca su valor al momento de la predicción, como es el caso de condición de venta. Ahora usaremos la función filter para quedarnos solo con las observaciones con condición de venta “normal”. ames_housing %&gt;% filter(Sale_Condition == &quot;Normal&quot;) ## # A tibble: 2,413 × 74 ## MS_Sub…¹ MS_Zo…² Lot_F…³ Lot_A…⁴ Street Alley Lot_S…⁵ Land_…⁶ Utili…⁷ Lot_C…⁸ ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 One_Sto… Reside… 141 31770 Pave No_A… Slight… Lvl AllPub Corner ## 2 One_Sto… Reside… 80 11622 Pave No_A… Regular Lvl AllPub Inside ## 3 One_Sto… Reside… 81 14267 Pave No_A… Slight… Lvl AllPub Corner ## 4 One_Sto… Reside… 93 11160 Pave No_A… Regular Lvl AllPub Corner ## 5 Two_Sto… Reside… 74 13830 Pave No_A… Slight… Lvl AllPub Inside ## 6 Two_Sto… Reside… 78 9978 Pave No_A… Slight… Lvl AllPub Inside ## 7 One_Sto… Reside… 41 4920 Pave No_A… Regular Lvl AllPub Inside ## 8 One_Sto… Reside… 43 5005 Pave No_A… Slight… HLS AllPub Inside ## 9 One_Sto… Reside… 39 5389 Pave No_A… Slight… Lvl AllPub Inside ## 10 Two_Sto… Reside… 60 7500 Pave No_A… Regular Lvl AllPub Inside ## # … with 2,403 more rows, 64 more variables: Land_Slope &lt;chr&gt;, ## # Neighborhood &lt;chr&gt;, Condition_1 &lt;chr&gt;, Condition_2 &lt;chr&gt;, Bldg_Type &lt;chr&gt;, ## # House_Style &lt;chr&gt;, Overall_Cond &lt;chr&gt;, Year_Built &lt;dbl&gt;, ## # Year_Remod_Add &lt;dbl&gt;, Roof_Style &lt;chr&gt;, Roof_Matl &lt;chr&gt;, ## # Exterior_1st &lt;chr&gt;, Exterior_2nd &lt;chr&gt;, Mas_Vnr_Type &lt;chr&gt;, ## # Mas_Vnr_Area &lt;dbl&gt;, Exter_Cond &lt;chr&gt;, Foundation &lt;chr&gt;, Bsmt_Cond &lt;chr&gt;, ## # Bsmt_Exposure &lt;chr&gt;, BsmtFin_Type_1 &lt;chr&gt;, BsmtFin_SF_1 &lt;dbl&gt;, … También se puede usar para filtrar variables numéricas: ames_housing %&gt;% filter(Lot_Area &gt; 1000 &amp; Sale_Price &gt;= 150000) ## # A tibble: 1,677 × 74 ## MS_Sub…¹ MS_Zo…² Lot_F…³ Lot_A…⁴ Street Alley Lot_S…⁵ Land_…⁶ Utili…⁷ Lot_C…⁸ ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 One_Sto… Reside… 141 31770 Pave No_A… Slight… Lvl AllPub Corner ## 2 One_Sto… Reside… 81 14267 Pave No_A… Slight… Lvl AllPub Corner ## 3 One_Sto… Reside… 93 11160 Pave No_A… Regular Lvl AllPub Corner ## 4 Two_Sto… Reside… 74 13830 Pave No_A… Slight… Lvl AllPub Inside ## 5 Two_Sto… Reside… 78 9978 Pave No_A… Slight… Lvl AllPub Inside ## 6 One_Sto… Reside… 41 4920 Pave No_A… Regular Lvl AllPub Inside ## 7 One_Sto… Reside… 43 5005 Pave No_A… Slight… HLS AllPub Inside ## 8 One_Sto… Reside… 39 5389 Pave No_A… Slight… Lvl AllPub Inside ## 9 Two_Sto… Reside… 60 7500 Pave No_A… Regular Lvl AllPub Inside ## 10 Two_Sto… Reside… 75 10000 Pave No_A… Slight… Lvl AllPub Corner ## # … with 1,667 more rows, 64 more variables: Land_Slope &lt;chr&gt;, ## # Neighborhood &lt;chr&gt;, Condition_1 &lt;chr&gt;, Condition_2 &lt;chr&gt;, Bldg_Type &lt;chr&gt;, ## # House_Style &lt;chr&gt;, Overall_Cond &lt;chr&gt;, Year_Built &lt;dbl&gt;, ## # Year_Remod_Add &lt;dbl&gt;, Roof_Style &lt;chr&gt;, Roof_Matl &lt;chr&gt;, ## # Exterior_1st &lt;chr&gt;, Exterior_2nd &lt;chr&gt;, Mas_Vnr_Type &lt;chr&gt;, ## # Mas_Vnr_Area &lt;dbl&gt;, Exter_Cond &lt;chr&gt;, Foundation &lt;chr&gt;, Bsmt_Cond &lt;chr&gt;, ## # Bsmt_Exposure &lt;chr&gt;, BsmtFin_Type_1 &lt;chr&gt;, BsmtFin_SF_1 &lt;dbl&gt;, … Notemos que en el ejemplo anterior se usa &amp;, que ayuda a filtrar por dos condiciones. También puede usarse | para filtrar por alguna de las dos condiciones. ames_housing %&gt;% filter(Lot_Area &lt; 1000 | Sale_Price &lt;= 150000) ## # A tibble: 1,271 × 74 ## MS_Sub…¹ MS_Zo…² Lot_F…³ Lot_A…⁴ Street Alley Lot_S…⁵ Land_…⁶ Utili…⁷ Lot_C…⁸ ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 One_Sto… Reside… 80 11622 Pave No_A… Regular Lvl AllPub Inside ## 2 One_Sto… Reside… 140 19138 Pave No_A… Regular Lvl AllPub Corner ## 3 One_Sto… Reside… 0 11241 Pave No_A… Slight… Lvl AllPub CulDSac ## 4 One_Sto… Reside… 0 12537 Pave No_A… Slight… Lvl AllPub CulDSac ## 5 One_Sto… Reside… 65 8450 Pave No_A… Regular Lvl AllPub Inside ## 6 One_Sto… Reside… 70 8400 Pave No_A… Regular Lvl AllPub Corner ## 7 One_Sto… Reside… 70 10500 Pave No_A… Regular Lvl AllPub FR2 ## 8 Two_Sto… Reside… 21 1680 Pave No_A… Regular Lvl AllPub Inside ## 9 Two_Sto… Reside… 21 1680 Pave No_A… Regular Lvl AllPub Inside ## 10 Two_Sto… Reside… 21 1680 Pave No_A… Regular Lvl AllPub Inside ## # … with 1,261 more rows, 64 more variables: Land_Slope &lt;chr&gt;, ## # Neighborhood &lt;chr&gt;, Condition_1 &lt;chr&gt;, Condition_2 &lt;chr&gt;, Bldg_Type &lt;chr&gt;, ## # House_Style &lt;chr&gt;, Overall_Cond &lt;chr&gt;, Year_Built &lt;dbl&gt;, ## # Year_Remod_Add &lt;dbl&gt;, Roof_Style &lt;chr&gt;, Roof_Matl &lt;chr&gt;, ## # Exterior_1st &lt;chr&gt;, Exterior_2nd &lt;chr&gt;, Mas_Vnr_Type &lt;chr&gt;, ## # Mas_Vnr_Area &lt;dbl&gt;, Exter_Cond &lt;chr&gt;, Foundation &lt;chr&gt;, Bsmt_Cond &lt;chr&gt;, ## # Bsmt_Exposure &lt;chr&gt;, BsmtFin_Type_1 &lt;chr&gt;, BsmtFin_SF_1 &lt;dbl&gt;, … Las condiciones pueden ser expresiones lógicas construidas mediante los operadores relacionales y lógicos: &lt; : Menor que &gt; : Mayor que == : Igual que &lt;= : Menor o igual que &gt;= : Mayor o igual que != : Diferente que %in% : Pertenece al conjunto is.na : Es NA !is.na : No es NA EJERCICIO: Practicar la función de filtro de observaciones usando los operadores auxiliares. Concatenar el resultado de seleccionar columnas y posteriormente filtrar columnas. 2.4.3 Ordenar registros La función arrange() se utiliza para ordenar las filas de un data frame de acuerdo a una o varias variables. Este ordenamiento puede ser ascendente o descendente. Por defecto arrange() ordena las filas por orden ascendente: ames_housing %&gt;% arrange(Sale_Price) ## # A tibble: 2,930 × 74 ## MS_Sub…¹ MS_Zo…² Lot_F…³ Lot_A…⁴ Street Alley Lot_S…⁵ Land_…⁶ Utili…⁷ Lot_C…⁸ ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 One_Sto… Reside… 68 9656 Pave No_A… Regular Lvl AllPub Inside ## 2 One_Sto… A_agr 80 14584 Pave No_A… Regular Low AllPub Inside ## 3 One_Sto… C_all 60 7879 Pave No_A… Regular Lvl AllPub Inside ## 4 One_Sto… Reside… 60 8088 Pave Grav… Regular Lvl AllPub Inside ## 5 One_Sto… C_all 50 9000 Pave No_A… Regular Lvl AllPub Inside ## 6 One_and… Reside… 50 5925 Pave No_A… Regular Lvl AllPub Inside ## 7 One_Sto… Reside… 50 5000 Pave No_A… Regular Low AllPub Inside ## 8 Two_Sto… C_all 50 8500 Pave Paved Regular Lvl AllPub Inside ## 9 One_Sto… C_all 72 9392 Pave No_A… Regular Lvl AllPub Corner ## 10 One_Sto… Reside… 50 5925 Pave No_A… Regular Lvl AllPub Corner ## # … with 2,920 more rows, 64 more variables: Land_Slope &lt;chr&gt;, ## # Neighborhood &lt;chr&gt;, Condition_1 &lt;chr&gt;, Condition_2 &lt;chr&gt;, Bldg_Type &lt;chr&gt;, ## # House_Style &lt;chr&gt;, Overall_Cond &lt;chr&gt;, Year_Built &lt;dbl&gt;, ## # Year_Remod_Add &lt;dbl&gt;, Roof_Style &lt;chr&gt;, Roof_Matl &lt;chr&gt;, ## # Exterior_1st &lt;chr&gt;, Exterior_2nd &lt;chr&gt;, Mas_Vnr_Type &lt;chr&gt;, ## # Mas_Vnr_Area &lt;dbl&gt;, Exter_Cond &lt;chr&gt;, Foundation &lt;chr&gt;, Bsmt_Cond &lt;chr&gt;, ## # Bsmt_Exposure &lt;chr&gt;, BsmtFin_Type_1 &lt;chr&gt;, BsmtFin_SF_1 &lt;dbl&gt;, … Si las queremos ordenar de forma ascendente, lo haremos del siguiente modo: ames_housing %&gt;% arrange(desc(Sale_Price)) ## # A tibble: 2,930 × 74 ## MS_Sub…¹ MS_Zo…² Lot_F…³ Lot_A…⁴ Street Alley Lot_S…⁵ Land_…⁶ Utili…⁷ Lot_C…⁸ ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Two_Sto… Reside… 104 21535 Pave No_A… Slight… Lvl AllPub Corner ## 2 Two_Sto… Reside… 160 15623 Pave No_A… Slight… Lvl AllPub Corner ## 3 Two_Sto… Reside… 118 35760 Pave No_A… Slight… Lvl AllPub CulDSac ## 4 One_Sto… Reside… 106 12720 Pave No_A… Regular HLS AllPub Inside ## 5 One_Sto… Reside… 100 12919 Pave No_A… Slight… Lvl AllPub Inside ## 6 One_Sto… Reside… 105 13693 Pave No_A… Regular Lvl AllPub Inside ## 7 One_Sto… Reside… 52 51974 Pave No_A… Slight… Lvl AllPub CulDSac ## 8 Two_Sto… Reside… 114 17242 Pave No_A… Slight… Lvl AllPub Inside ## 9 Two_Sto… Reside… 107 13891 Pave No_A… Regular Lvl AllPub Inside ## 10 Two_Sto… Reside… 85 16056 Pave No_A… Slight… Lvl AllPub Inside ## # … with 2,920 more rows, 64 more variables: Land_Slope &lt;chr&gt;, ## # Neighborhood &lt;chr&gt;, Condition_1 &lt;chr&gt;, Condition_2 &lt;chr&gt;, Bldg_Type &lt;chr&gt;, ## # House_Style &lt;chr&gt;, Overall_Cond &lt;chr&gt;, Year_Built &lt;dbl&gt;, ## # Year_Remod_Add &lt;dbl&gt;, Roof_Style &lt;chr&gt;, Roof_Matl &lt;chr&gt;, ## # Exterior_1st &lt;chr&gt;, Exterior_2nd &lt;chr&gt;, Mas_Vnr_Type &lt;chr&gt;, ## # Mas_Vnr_Area &lt;dbl&gt;, Exter_Cond &lt;chr&gt;, Foundation &lt;chr&gt;, Bsmt_Cond &lt;chr&gt;, ## # Bsmt_Exposure &lt;chr&gt;, BsmtFin_Type_1 &lt;chr&gt;, BsmtFin_SF_1 &lt;dbl&gt;, … Si se desea usar dos o más columnas para realizar el ordenamiento, deben separarse por comas cada una de las características ames_housing %&gt;% arrange(Sale_Condition, desc(Sale_Price), Lot_Area) %&gt;% select(Sale_Condition, Sale_Price, Lot_Area) ## # A tibble: 2,930 × 3 ## Sale_Condition Sale_Price Lot_Area ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Abnorml 745000 15623 ## 2 Abnorml 552000 14836 ## 3 Abnorml 475000 11778 ## 4 Abnorml 390000 13418 ## 5 Abnorml 328900 5119 ## 6 Abnorml 310000 14541 ## 7 Abnorml 290000 9950 ## 8 Abnorml 287000 15498 ## 9 Abnorml 258000 12090 ## 10 Abnorml 257000 10994 ## # … with 2,920 more rows Notemos que en el ejemplo anterior usamos dos pipes (%&gt;%), como habíamos mencionado se pueden usar los necesarios para combinar funciones. 2.4.4 Agregar / Modificar Con la función mutate() podemos computar transformaciones de variables en un data frame. A menudo, tendremos la necesidad de crear nuevas variables que se calculan a partir de variables existentes. La función mutate() proporciona una interfaz clara para realizar este tipo de operaciones. Por ejemplo, haremos el cálculo de la antigüedad del inmueble a partir de las variables Year_Sold y Year_Remod_Add: ejemplo_mutate &lt;- ames_housing %&gt;% select(Year_Sold, Year_Remod_Add) %&gt;% mutate(Antique = Year_Sold - Year_Remod_Add) ejemplo_mutate ## # A tibble: 2,930 × 3 ## Year_Sold Year_Remod_Add Antique ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2010 1960 50 ## 2 2010 1961 49 ## 3 2010 1958 52 ## 4 2010 1968 42 ## 5 2010 1998 12 ## 6 2010 1998 12 ## 7 2010 2001 9 ## 8 2010 1992 18 ## 9 2010 1996 14 ## 10 2010 1999 11 ## # … with 2,920 more rows El ejemplo anterior crea una nueva variable. Ahora se presenta otro ejemplo en donde se modifica una variable ya creada. ejemplo_mutate %&gt;% mutate(Antique = Antique * 12) ## # A tibble: 2,930 × 3 ## Year_Sold Year_Remod_Add Antique ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2010 1960 600 ## 2 2010 1961 588 ## 3 2010 1958 624 ## 4 2010 1968 504 ## 5 2010 1998 144 ## 6 2010 1998 144 ## 7 2010 2001 108 ## 8 2010 1992 216 ## 9 2010 1996 168 ## 10 2010 1999 132 ## # … with 2,920 more rows En este segundo ejemplo, se modifica el número de años de antigüedad y se multiplica por un factor de 12 para modificar el tiempo en una escala de meses. 2.4.5 Resumen estadístico La función summarise() se comporta de forma análoga a la función mutate(), excepto que en lugar de añadir nuevas columnas crea un nuevo data frame. Podemos usar el ejemplo anterior y calcular la media de la variable creada Antique: ames_housing %&gt;% select(Year_Sold, Year_Remod_Add) %&gt;% mutate(Antique = Year_Sold - Year_Remod_Add) %&gt;% summarise(Mean_Antique = mean(Antique)) ## # A tibble: 1 × 1 ## Mean_Antique ## &lt;dbl&gt; ## 1 23.5 Solo fue necesario agregar un pipe, especificar el nombre de la variable creada y la operación a realizar. A continuación se muestran funciones que trabajando conjuntamente con la función summarise() facilitarán nuestro trabajo diario. Las primeras pertenecen al paquete base y las otras son del paquete dplyr. Todas ellas toman como argumento un vector y devuelven un único resultado: min(), max() : Valores max y min. mean() : Media. median() : Mediana. sum() : Suma de los valores. var(), sd() : Varianza y desviación estándar. first() : Primer valor en un vector. last() : El último valor en un vector n() : El número de valores en un vector. n_distinct() : El número de valores distintos en un vector. nth() : Extrae el valor que ocupa la posición n en un vector. Mas adelante veremos como combinar esta función con la función group_by() para calcular estadísticos agrupados por alguna característica de interés. EJERCICIO: Realizar una consulta usando summarise() y cada una de las funciones estadísticas listadas anteriormente. 2.4.6 Agrupamiento La función group_by() agrupa un conjunto de filas de acuerdo con los valores de una o más columnas o expresiones. Usaremos el ejemplo anterior. Primero creamos nuestra nueva variable Antique, después agrupamos por vecindario y al final calculamos la media de la variable Antique. Gracias al agrupamiento, nos regresara una media por cada grupo creado, es decir, nos regresara el promedio de la antigüedad por vecindario. ames_housing %&gt;% mutate(Antique = Year_Sold - Year_Remod_Add) %&gt;% group_by(Neighborhood) %&gt;% summarise(Mean_Antique = round(mean(Antique), 0)) ## # A tibble: 28 × 2 ## Neighborhood Mean_Antique ## &lt;chr&gt; &lt;dbl&gt; ## 1 Bloomington_Heights 2 ## 2 Blueste 25 ## 3 Briardale 35 ## 4 Brookside 39 ## 5 Clear_Creek 28 ## 6 College_Creek 8 ## 7 Crawford 29 ## 8 Edwards 33 ## 9 Gilbert 9 ## 10 Green_Hills 14 ## # … with 18 more rows ¡¡ RECORDAR !! En este link se encuentra un buen resumen de las funciones básicas de dplyr 2.5 Orden y estructura Un conjunto de datos puede ser representado de muchas maneras distintas y contener en todos los casos la misma información. Sin embargo, no todos los modos en que se presenta la información resulta óptimo para su procesamiento y análisis. Los conjuntos de datos ordenados serán más fáciles de trabajar y analizar. Algunas de las características principales que presentan los conjuntos de datos ordenados son las siguientes: Cada variable debe tener su propia columna. Cada observación debe tener su propio renglón. Cada valor debe tener su propia celda. La figura anterior muestra la estructura de orden que debe tener un conjunto de datos. A pesar de que pueda parecer intuitivo y sencillo, en la práctica es considerable el número de conjuntos de datos desordenados. La limpieza y ordenamiento debe ser trabajado de forma impecable a fin de que puedan realizarse buenas prácticas. El tiempo de limpieza y ordenamiento varía mucho dependiendo de la dimensión del conjunto de datos. Algunos de los principales problemas que pueden tener los conjuntos de datos no ordenados son: Una variable puede estar dispersa en múltiples columnas Una observación puede estar esparcida en múltiples renglones La paquetería tidyr cuenta con funciones para resolver dichos problemas. Entre las principales funciones que tiene la paquetería, se encuentran pivot_longer(), pivot_wider(), separate() y unite(), mismas que se analizarán a continuación. 2.5.1 Pivote horizontal La función pivot_wider() resulta muy útil a la hora de organizar los datos. Su función consiste en dispersar una variable clave en múltiples columnas. Lo primero que se debe hacer para poder hacer uso de dicha función es instalar y cargar la librería. El siguiente conjunto de datos contiene el número de localidades rurales y urbanas por municipio de la Ciudad de México. Como es posible observar, algunos municipios aparecen más de una vez en el marco de datos, esto se debe a que cada municipio puede tener ambos ámbitos, rural y urbano. Para hacer que el conjunto de datos sea ordenado, es necesario que cada observación aparezca una sola vez por renglón y cada una de las categorías (rural y urbano) de la variable “Ámbito” deberá ocupar el lugar de una columna. El siguiente código muestra cómo convertir los datos no ordenados en un conjunto ordenado. library(tidyr) Resumen &lt;- readRDS(&quot;data/loc_mun_cdmx.rds&quot;) Resumen %&gt;% pivot_wider( names_from = Ambito, values_from = Total_localidades ) ## # A tibble: 16 × 3 ## NOM_MUN Rural Urbano ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Álvaro Obregón 3 1 ## 2 La Magdalena Contreras 8 1 ## 3 Cuajimalpa de Morelos 14 2 ## 4 Tláhuac 31 5 ## 5 Xochimilco 78 1 ## 6 Tlalpan 95 4 ## 7 Milpa Alta 187 10 ## 8 Azcapotzalco NA 1 ## 9 Benito Juárez NA 1 ## 10 Coyoacán NA 1 ## 11 Cuauhtémoc NA 1 ## 12 Gustavo A. Madero NA 1 ## 13 Iztacalco NA 1 ## 14 Iztapalapa NA 1 ## 15 Miguel Hidalgo NA 1 ## 16 Venustiano Carranza NA 1 En la tabla actual existe ahora un y solo un registro por cada observación (nombre de municipio en este caso). El valor que le corresponde a cada una de las columnas creadas es la frecuencia absoluta de localidades que tienen la característica “Rural” y “Urbano” respectivamente. Pero… ¿qué pasa cuando no existen todos los valores en ambas columnas? Si no se especifica la manera de llenar los datos faltantes, estos contendrán NAs. Siempre se puede elegir el caracter o número con el cual se imputan los datos faltantes. fish_encounters %&gt;% pivot_wider(names_from = station, values_from = seen) ## # A tibble: 19 × 12 ## fish Release I80_1 Lisbon Rstr Base_TD BCE BCW BCE2 BCW2 MAE MAW ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 4842 1 1 1 1 1 1 1 1 1 1 1 ## 2 4843 1 1 1 1 1 1 1 1 1 1 1 ## 3 4844 1 1 1 1 1 1 1 1 1 1 1 ## 4 4845 1 1 1 1 1 NA NA NA NA NA NA ## 5 4847 1 1 1 NA NA NA NA NA NA NA NA ## 6 4848 1 1 1 1 NA NA NA NA NA NA NA ## 7 4849 1 1 NA NA NA NA NA NA NA NA NA ## 8 4850 1 1 NA 1 1 1 1 NA NA NA NA ## 9 4851 1 1 NA NA NA NA NA NA NA NA NA ## 10 4854 1 1 NA NA NA NA NA NA NA NA NA ## 11 4855 1 1 1 1 1 NA NA NA NA NA NA ## 12 4857 1 1 1 1 1 1 1 1 1 NA NA ## 13 4858 1 1 1 1 1 1 1 1 1 1 1 ## 14 4859 1 1 1 1 1 NA NA NA NA NA NA ## 15 4861 1 1 1 1 1 1 1 1 1 1 1 ## 16 4862 1 1 1 1 1 1 1 1 1 NA NA ## 17 4863 1 1 NA NA NA NA NA NA NA NA NA ## 18 4864 1 1 NA NA NA NA NA NA NA NA NA ## 19 4865 1 1 1 NA NA NA NA NA NA NA NA fish_encounters %&gt;% pivot_wider(names_from = station, values_from = seen, values_fill = 0) ## # A tibble: 19 × 12 ## fish Release I80_1 Lisbon Rstr Base_TD BCE BCW BCE2 BCW2 MAE MAW ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 4842 1 1 1 1 1 1 1 1 1 1 1 ## 2 4843 1 1 1 1 1 1 1 1 1 1 1 ## 3 4844 1 1 1 1 1 1 1 1 1 1 1 ## 4 4845 1 1 1 1 1 0 0 0 0 0 0 ## 5 4847 1 1 1 0 0 0 0 0 0 0 0 ## 6 4848 1 1 1 1 0 0 0 0 0 0 0 ## 7 4849 1 1 0 0 0 0 0 0 0 0 0 ## 8 4850 1 1 0 1 1 1 1 0 0 0 0 ## 9 4851 1 1 0 0 0 0 0 0 0 0 0 ## 10 4854 1 1 0 0 0 0 0 0 0 0 0 ## 11 4855 1 1 1 1 1 0 0 0 0 0 0 ## 12 4857 1 1 1 1 1 1 1 1 1 0 0 ## 13 4858 1 1 1 1 1 1 1 1 1 1 1 ## 14 4859 1 1 1 1 1 0 0 0 0 0 0 ## 15 4861 1 1 1 1 1 1 1 1 1 1 1 ## 16 4862 1 1 1 1 1 1 1 1 1 0 0 ## 17 4863 1 1 0 0 0 0 0 0 0 0 0 ## 18 4864 1 1 0 0 0 0 0 0 0 0 0 ## 19 4865 1 1 1 0 0 0 0 0 0 0 0 Ejercicio: Realiza un pivote horizontal a través del ámbito y el total de localidades. Rellena los datos faltantes con ceros. En caso de que existan múltiples columnas que se desean dispersar mediante el pivote de una columna con múltiples categorías, es posible especificar tal re estructuración a través del siguiente código. us_rent_income %&gt;% arrange(NAME) ## # A tibble: 104 × 5 ## GEOID NAME variable estimate moe ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 Alabama income 24476 136 ## 2 01 Alabama rent 747 3 ## 3 02 Alaska income 32940 508 ## 4 02 Alaska rent 1200 13 ## 5 04 Arizona income 27517 148 ## 6 04 Arizona rent 972 4 ## 7 05 Arkansas income 23789 165 ## 8 05 Arkansas rent 709 5 ## 9 06 California income 29454 109 ## 10 06 California rent 1358 3 ## # … with 94 more rows us_rent_income %&gt;% pivot_wider(names_from = variable, values_from = c(estimate, moe)) ## # A tibble: 52 × 6 ## GEOID NAME estimate_income estimate_rent moe_income moe_rent ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 01 Alabama 24476 747 136 3 ## 2 02 Alaska 32940 1200 508 13 ## 3 04 Arizona 27517 972 148 4 ## 4 05 Arkansas 23789 709 165 5 ## 5 06 California 29454 1358 109 3 ## 6 08 Colorado 32401 1125 109 5 ## 7 09 Connecticut 35326 1123 195 5 ## 8 10 Delaware 31560 1076 247 10 ## 9 11 District of Columbia 43198 1424 681 17 ## 10 12 Florida 25952 1077 70 3 ## # … with 42 more rows Ejercicio: Agrupa los datos de localidades por ámbito Agrega una columna con el porcentaje de localidades por alcaldía Realiza un pivote horizontal sobre el ámbito y las variables numéricas de total de localidades y su respectivo porcentaje creado en el paso anterior Ordena los registros de forma descendente de acuerdo con el total de localidades rural y urbano. Adicionalmente, se puede especificar una función de agregación que operara antes de acomodar los datos en las respectivas columnas indicadas. Un ejemplo de funciones agregadas en la re estructuración de tabla se muestra a continuación, donde se muestra la media de los valores en las categorías tension y breaks. warpbreaks &lt;- warpbreaks[c(&quot;wool&quot;, &quot;tension&quot;, &quot;breaks&quot;)] %&gt;% as_tibble() warpbreaks ## # A tibble: 54 × 3 ## wool tension breaks ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; ## 1 A L 26 ## 2 A L 30 ## 3 A L 54 ## 4 A L 25 ## 5 A L 70 ## 6 A L 52 ## 7 A L 51 ## 8 A L 26 ## 9 A L 67 ## 10 A M 18 ## # … with 44 more rows warpbreaks %&gt;% pivot_wider( names_from = wool, values_from = breaks, values_fn = ~mean(.x, na.rm = T) ) ## # A tibble: 3 × 3 ## tension A B ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 L 44.6 28.2 ## 2 M 24 28.8 ## 3 H 24.6 18.8 Ejercicio: Sobre el conjunto de localidades crea una variable con 5 categorías numéricas creadas aleatoriamente. Elimina la columna con el nombre del municipio. Crea un pivote horizontal con el ámbito, sumando el total de localidades y rellenando con ceros los datos faltantes. Ordena las categorías numéricas de forma ascendente. 2.5.2 Pivote vertical pivot_longer() es podría ser la función inversa de la anterior, se necesita comúnmente para ordenar los conjuntos de datos capturados en crudo, ya que a menudo no son capturados acorde a las mejores estructuras para facilitar el análisis. El conjunto de datos relig_income almacena recuentos basados en una encuesta que (entre otras cosas) preguntó a las personas sobre su religión e ingresos anuales: relig_income ## # A tibble: 18 × 11 ## religion `&lt;$10k` $10-2…¹ $20-3…² $30-4…³ $40-5…⁴ $50-7…⁵ $75-1…⁶ $100-…⁷ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Agnostic 27 34 60 81 76 137 122 109 ## 2 Atheist 12 27 37 52 35 70 73 59 ## 3 Buddhist 27 21 30 34 33 58 62 39 ## 4 Catholic 418 617 732 670 638 1116 949 792 ## 5 Don’t know/r… 15 14 15 11 10 35 21 17 ## 6 Evangelical … 575 869 1064 982 881 1486 949 723 ## 7 Hindu 1 9 7 9 11 34 47 48 ## 8 Historically… 228 244 236 238 197 223 131 81 ## 9 Jehovah&#39;s Wi… 20 27 24 24 21 30 15 11 ## 10 Jewish 19 19 25 25 30 95 69 87 ## 11 Mainline Prot 289 495 619 655 651 1107 939 753 ## 12 Mormon 29 40 48 51 56 112 85 49 ## 13 Muslim 6 7 9 10 9 23 16 8 ## 14 Orthodox 13 17 23 32 32 47 38 42 ## 15 Other Christ… 9 7 11 13 13 14 18 14 ## 16 Other Faiths 20 33 40 46 49 63 46 40 ## 17 Other World … 5 2 3 4 2 7 3 4 ## 18 Unaffiliated 217 299 374 365 341 528 407 321 ## # … with 2 more variables: `&gt;150k` &lt;dbl&gt;, `Don&#39;t know/refused` &lt;dbl&gt;, and ## # abbreviated variable names ¹​`$10-20k`, ²​`$20-30k`, ³​`$30-40k`, ⁴​`$40-50k`, ## # ⁵​`$50-75k`, ⁶​`$75-100k`, ⁷​`$100-150k` ¿Crees que ésta es la mejor estructura para la tabla? ¿Cómo imaginas que podría modificarse? Este conjunto de datos contiene tres variables: religión, almacenada en las filas income repartidos entre los nombres de columna count almacenado en los valores de las celdas. Para ordenarlo usamos pivot_longer(): relig_income %&gt;% pivot_longer(cols = -religion, names_to = &quot;income&quot;, values_to = &quot;count&quot;) ## # A tibble: 180 × 3 ## religion income count ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Agnostic &lt;$10k 27 ## 2 Agnostic $10-20k 34 ## 3 Agnostic $20-30k 60 ## 4 Agnostic $30-40k 81 ## 5 Agnostic $40-50k 76 ## 6 Agnostic $50-75k 137 ## 7 Agnostic $75-100k 122 ## 8 Agnostic $100-150k 109 ## 9 Agnostic &gt;150k 84 ## 10 Agnostic Don&#39;t know/refused 96 ## # … with 170 more rows El primer argumento es el conjunto de datos para remodelar, relig_income. El segundo argumento describe qué columnas necesitan ser reformadas. En este caso, es cada columna aparte de religion. El names_to da el nombre de la variable que se creará a partir de los datos almacenados en los nombres de columna, es decir, ingresos. Los values_to dan el nombre de la variable que se creará a partir de los datos almacenados en el valor de la celda, es decir, count. Ni la columna names_to ni la values_to existen en relig_income, por lo que las proporcionamos como cadenas de caracteres entre comillas. 2.5.3 Unión de columnas Es común que en los conjuntos de datos exista información esparcida en distintas columnas que sería deseable (en muy pocas ocasiones) tenerlas en una sola columna. Algunos ejemplos de esta situación deseable son las fechas y claves geoestadísticas. La función unite() sirve para concatenar el contenido de columnas mediante un separador elegible. Se usará la variable de la clave geoestadística de localidades del país como ejemplo. El formato para las claves geoestadísticas para estado, municipio y localidad son claves alfanuméricas que contienen 2, 3 y 4 caracteres respectivamente. Es indispensable que al trabajar con claves geoestadísticas, las claves estén en su formato original. A continuación se hará la homologación de las claves para usar la función unite(). library(magrittr) library(readxl) library(stringr) Datos &lt;- read_excel(&quot;data/Margin CONAPO.xlsx&quot;, sheet = &quot;Margin CONAPO&quot;) Datos ## # A tibble: 107,458 × 21 ## ENT NOM_ENT MUN NOM_MUN LOC NOM_LOC POB_TOT VPH ANAL10 SPRIM10 ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Aguascalient… 1 Aguasc… 1 Aguasc… 722250 184123 2.26 10.9 ## 2 1 Aguascalient… 1 Aguasc… 96 Agua A… 37 11 17.9 48.1 ## 3 1 Aguascalient… 1 Aguasc… 104 Ardill… 14 3 0 20 ## 4 1 Aguascalient… 1 Aguasc… 106 Arella… 1382 255 5.60 24.7 ## 5 1 Aguascalient… 1 Aguasc… 112 Bajío … 55 11 14.3 38.1 ## 6 1 Aguascalient… 1 Aguasc… 114 Reside… 757 202 0 1.63 ## 7 1 Aguascalient… 1 Aguasc… 120 Buenav… 935 217 10.7 29.5 ## 8 1 Aguascalient… 1 Aguasc… 121 Cabeci… 184 44 4.55 32.6 ## 9 1 Aguascalient… 1 Aguasc… 125 Cañada… 395 82 8.86 23.9 ## 10 1 Aguascalient… 1 Aguasc… 126 Cañada… 509 123 4.75 19.6 ## # … with 107,448 more rows, and 11 more variables: SEXC10 &lt;dbl&gt;, SEE10 &lt;dbl&gt;, ## # SAGUAE10 &lt;dbl&gt;, PROM_OCC10 &lt;dbl&gt;, PISOTIE10 &lt;dbl&gt;, SREFRI10 &lt;dbl&gt;, ## # IM_2010 &lt;dbl&gt;, GM_2010 &lt;chr&gt;, IMC0A100 &lt;dbl&gt;, LUG_NAL &lt;dbl&gt;, LUG_EDO &lt;dbl&gt; Como puede apreciarse en la tabla anterior, las claves de los campos Ent, Mun y Loc aparecen como numéricos. La estructura deseada para estos campos es de tipo alfanumérico y de longitud 2, 3 y 4 respectivamente. Para lograr esta estructura de datos, es necesario concatenar tantos ceros como sean necesarios antes del valor actual hasta lograr la longitud deseada. Datos2 &lt;- Datos %&gt;% select(ENT, MUN, LOC) Datos2$ENT %&lt;&gt;% str_pad(width = 2, side = &quot;left&quot;, pad = &quot;0&quot;) Datos2$MUN %&lt;&gt;% str_pad(width = 3, side = &quot;left&quot;, pad = &quot;0&quot;) Datos2$LOC %&lt;&gt;% str_pad(width = 4, side = &quot;left&quot;, pad = &quot;0&quot;) Datos2 %&gt;% head(5) ## # A tibble: 5 × 3 ## ENT MUN LOC ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 01 001 0001 ## 2 01 001 0096 ## 3 01 001 0104 ## 4 01 001 0106 ## 5 01 001 0112 Datos2 %&gt;% unite(&quot;CVE_GEO&quot;, c(&quot;ENT&quot;,&quot;MUN&quot;,&quot;LOC&quot;), sep=&quot;&quot;, remove = F) %&gt;% head(5) ## # A tibble: 5 × 4 ## CVE_GEO ENT MUN LOC ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 010010001 01 001 0001 ## 2 010010096 01 001 0096 ## 3 010010104 01 001 0104 ## 4 010010106 01 001 0106 ## 5 010010112 01 001 0112 Datos2 %&gt;% unite(&quot;CVE_GEO&quot;, c(&quot;ENT&quot;,&quot;MUN&quot;,&quot;LOC&quot;), sep=&quot;/&quot;,remove = T) %&gt;% head(5) ## # A tibble: 5 × 1 ## CVE_GEO ## &lt;chr&gt; ## 1 01/001/0001 ## 2 01/001/0096 ## 3 01/001/0104 ## 4 01/001/0106 ## 5 01/001/0112 En el código anterior se carga la librería magrittr para poder hacer uso del operador pipe doble “%&lt;&gt;%”, que permite al igual que el operador pipe simple “%&gt;%”, usar como argumento al primer elemento y mandarlo hacia la función definida, además de guardar el resultado final de la cadena de pipes en el argumento original que fue usado como insumo para la función. Es importante tener en cuenta que el dato será reescrito y no se podrá tener acceso a su información almacenada antes de ser usado el operador. Es opción del programador poder eliminar las variables originales que crearon la nueva variable o mantenerlas en el conjunto de datos. Esta opción está disponible en el parámetro remove de la función unite(). 2.5.4 Separador de columnas Los procesos que se han visto hasta ahora han tenido cada uno una función inversa, este es también el caso de la función unite que tiene por objetivo unir dos o más columnas en una. La función separate() separará una columna en dos o más dependiendo de la longitud que tenga y de las especificaciones de separación. Datos_unite1 &lt;- Datos2 %&gt;% unite(&quot;CVE_GEO&quot;, c(&quot;ENT&quot;,&quot;MUN&quot;,&quot;LOC&quot;), sep = &quot;&quot;, remove = T) Datos_unite1 %&gt;% head(5) ## # A tibble: 5 × 1 ## CVE_GEO ## &lt;chr&gt; ## 1 010010001 ## 2 010010096 ## 3 010010104 ## 4 010010106 ## 5 010010112 Datos_unite1 %&gt;% separate(&quot;CVE_GEO&quot;, c(&quot;EDO&quot;,&quot;MUNI&quot;,&quot;LOC&quot;), sep = c(2, 5), remove=F) %&gt;% head(5) ## # A tibble: 5 × 4 ## CVE_GEO EDO MUNI LOC ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 010010001 01 001 0001 ## 2 010010096 01 001 0096 ## 3 010010104 01 001 0104 ## 4 010010106 01 001 0106 ## 5 010010112 01 001 0112 Ya sea que se le especifique el número de caracteres que debe de contar para hacer un corte o que se le indique qué caracter debe identificar para hacer la separación, la función separate() puede dividir la columna indicada y crear nuevas a partir de la original. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
