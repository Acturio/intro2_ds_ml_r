[["index.html", "Introducción a Ciencia de Datos y Machine Learning BIENVENIDA Objetivo Instructores Alcances del curso Duración y evaluación del curso Recursos y dinámica de clase", " Introducción a Ciencia de Datos y Machine Learning BIENVENIDA Objetivo Brindar al participante los elementos teóricos y prácticos básicos alrededor de la programación para el análisis de datos. Aprenderá a distinguir las diferentes soluciones a problemas que pueden resolverse con algoritmos de machine learning y aprenderá a usar el conjunto de librerías en R más novedosas, estructuradas y ampliamente usadas para la manipulación, transformación y visualización de datos: “TIDYVERSE”. Instructores ACT. ARTURO BRINGAS LinkedIn: arturo-bringas Email: act.arturo.b@ciencias.unam.mx Actuario egresado de la Facultad de Ciencias con maestría en Ciencia de Datos por el ITAM. Se especializa en modelos predictivos y de clasificación de machine learning aplicado a seguros, banca, marketing, deportes, e-commerce y movilidad internacional. Ha sido consultor Senior Data Scientist para empresas y organizaciones como GNP, El Universal, UNAM, la Organización de las Naciones Unidas Contra la Droga y el Delito (UNODC), entre otros. Actualmente es profesor de Ciencia de datos y Machine Learning en AMAT y Data Scientist Expert en BBVA, en donde implementa soluciones de analítica avanzada con impacto global. ACT. KARINA LIZETTE GAMBOA LinkedIn: KaLizzyGam Email: lizzygamboa@ciencias.unam.mx Actuaria egresada de la Facultad de Ciencias y candidata a Maestra en Ciencia de Datos por el ITAM. Experiencia en áreas de analítica predictiva e inteligencia del negocio. Lead y Senior Data Scientist en consultoría en diferentes sectores como tecnología, asegurador, financiero y bancario. Es experta en entendimiento de negocio para la correcta implementación de algoritmos de inteligencia y explotación de datos. Actualmente se desarrolla como lead data specialist en Merama, startup mexicana clasificada como uno de los nuevos unicornios de Latinoamérica. Senior Data Scientist en CLOSTER y como profesora del diplomado de Metodología de la Investigación Social por la UNAM así como instructora de cursos de Ciencia de Datos en AMAT. Empresas anteriores: GNP, Actinver Banco y Casa de Bolsa, PlayCity Casinos, RakenDataGroup Consulting, entre otros. Alcances del curso Al finalizar este curso, el participante será capaz de consumir, manipular y visualizar información para resolver problemas de propósito general asociados a los datos. Apenderá a implementar diferentes algoritmos de machine learning y mejorar su desempeño predictivo en problemas de clasificación, regresión y segmentación. Requisitos: Computadora con al menos 8Gb Ram Instalar la versión más reciente de R Instalar la versión más reciente de RStudio Temario: 1. Introducción a Ciencia de Datos Machine Learning, Bigdata, BI, AI y CD Objetivo de ciencia de datos Requisitos y aplicaciones Tipos de algoritmos Ciclo de vida de un proyecto 2. Manipulación de datos con Tidyverse Importación de tablas (readr) Consultas (dplyr) Transformación de estructuras (tidyr) 3. Concepto de Machine Learning Machine learning Análisis supervisado Análisis no supervisado Sesgo y varianza Partición de datos Preprocesamiento e ingeniería de datos 4. Algoritmos de Machine Learning Clustering: Kmeans, kmedoids, agnes Regresión Lineal Métricas de error Regresión logística Métricas de error KNN Árbol de decisión Random Forest Comparación de modelos Duración y evaluación del curso El programa tiene una duración de 40 hrs. Las clases serán impartidas los días sábado, de 9:00 am a 1:00 pm Serán asignados ejercicios que el participante deberá resolver entre una semana y otra. Al final del curso se solicitará un proyecto final, el cual deberá ser entregado para ser acreedor a la constancia de participación. Recursos y dinámica de clase En esta clase estaremos usando: R da click aquí si aún no lo descargas RStudio da click aquí también Zoom Clases Pulgar arriba: Voy bien, estoy entendiendo! Pulgar abajo: Eso no quedó muy claro Mano arriba: Quiero participar/preguntar ó Ya estoy listo para iniciar Google Drive Notas de clase Revisame si quieres aprender "],["conceptos-de-ciencia-de-datos.html", "Capítulo 1 Conceptos de Ciencia de Datos 1.1 ¿Qué es Ciencia de Datos? 1.2 Objetivos 1.3 Requisitos 1.4 Aplicaciones", " Capítulo 1 Conceptos de Ciencia de Datos 1.1 ¿Qué es Ciencia de Datos? Definiendo conceptos: Estadística Disciplina que recolecta, organiza, analiza e interpreta datos. Lo hace a través de una población muestral generando estadística descriptiva y estadística inferencial. La estadística descriptiva, como su nombre lo indica, se encarga de describir datos y obtener conclusiones. Se utilizan números (media, mediana, moda, mínimo, máximo, etc) para analizar datos y llegar a conclusiones de acuerdo a ellos. La estadística inferencial argumenta o infiere sus resultados a partir de las muestras de una población. Se intenta conseguir información al utilizar un procedimiento ordenado en el manejo de los datos de la muestra. La estadística predictiva busca estimar valores y escenarios futuros más probables de ocurrir a partir de referencias históricas previas. Se suelen ocupar como apoyo características y factores áltamente asociados al fenómeno que se desea predecir. Business Intelligence: BI aprovecha el software y los servicios para transformar los datos en conocimientos prácticos que informan las decisiones empresariales estratégicas y tácticas de una organización. Las herramientas de BI acceden y analizan conjuntos de datos y presentan hallazgos analíticos en informes, resúmenes, tableros, gráficos, cuadros, -indicadores- o KPI’s y mapas para proporcionar a los usuarios inteligencia detallada sobre el estado del negocio. BI esta enfocado en analizar la historia pasada para tomar decisiones hacia el futuro. ¿Qué características tiene un KPI? Específicos Continuos y periódicos Objetivos Cuantificables Medibles Realistas Concisos Coherentes Relevantes Machine Learning: Machine learning –aprendizaje de máquina– es una rama de la inteligencia artificial que permite que las máquinas aprendan de los patrones existentes en los datos. Se usan métodos computacionales para aprender de datos con el fin de producir reglas para mejorar el desempeño en alguna tarea o toma de decisión. (Está enfocado en la programación de máquinas para aprender de los patrones existentes en datos principalmente estructurados y anticiparse al futuro) Deep Learning: El aprendizaje profundo es un subcampo del aprendizaje automático que se ocupa de los algoritmos inspirados en la estructura y función del cerebro llamados redes neuronales artificiales. En Deep Learning, un modelo de computadora aprende a realizar tareas de clasificación directamente a partir de imágenes, texto o sonido. Los modelos de aprendizaje profundo pueden lograr una precisión de vanguardia, a veces superando el rendimiento a nivel humano. Los modelos se entrenan mediante el uso de un gran conjunto de datos etiquetados y arquitecturas de redes neuronales que contienen muchas capas. (Está enfocado en la programación de máquinas para el reconocimiento de imágenes y audio (datos no estructurados)) Big data se refiere a los grandes y diversos conjuntos de información que crecen a un ritmo cada vez mayor. Abarca el volumen de información, la velocidad a la que se crea y recopila, y la variedad o alcance de los puntos de datos que se cubren. Los macrodatos a menudo provienen de la minería de datos y llegan en múltiples formatos. Es común que se confunda los conceptos de Big Data y Big Compute, como se mencionó, Big Data se refiere al procesamiento de conjuntos de datos que son más voluminosos y complejos que los tradicionales y Big Compute a herramientas y enfoques que utilizan una gran cantidad de recursos de CPU y memoria de forma coordinada para resolver problemas que usan algoritmos muy complejos. Curiosidad: Servidores en líquido para ser enfriados Curiosidad 2: Centro de datos en el océano Entonces, ¿qué NO es ciencia de datos? No es una tecnología No es una herramienta No es desarrollo de software No es Business Intelligence* No es Big Data* No es Inteligencia Artificial* No es (solo) machine learning No es (solo) deep learning No es (solo) visualización No es (solo) hacer modelos 1.2 Objetivos Los científicos de datos analizan qué preguntas necesitan respuesta y dónde encontrar los datos relacionados. Tienen conocimiento de negocio y habilidades analíticas, así como la capacidad de extraer, limpiar y presentar datos. Las empresas utilizan científicos de datos para obtener, administrar y analizar grandes cantidades de datos no estructurados. Luego, los resultados se sintetizan y comunican a las partes interesadas clave para impulsar la toma de decisiones estratégicas en la organización. Fuente: Blog post de Drew Conway Más sobre Conway: Forbes 2016 1.3 Requisitos Background científico: Conocimientos generales de probabilidad, estadística, álgebra lineal, cálculo, geometría analítica, programación, conocimientos computacionales… etc Datos relevantes y suficientes: Es indispensable saber si los datos con los que se trabajará son relevantes y suficientes, debemos evaluar qué preguntas podemos responder con los datos con los que contamos. Suficiencia: Los datos con los que trabajamos tienen que ser representativos de la población en general, necesitamos que las características representadas en la información sean suficientes para aproximar a la población objetivo. Relevancia: De igual manera los datos tienen que tener relevancia para la tarea que queremos resolver, por ejemplo, es probable que información sobre gusto en alimentos sea irrelevante para predecir número de hijos. Etiquetas: Se necesita la intervención humana para etiquetar, clasificar e introducir los datos en el algoritmo. Software: Existen distintos lenguajes de programación para realizar ciencia de datos 1.4 Aplicaciones Dependiendo de la industria en la que se quiera aplicar Machine Learning, podemos pensar en distintos enfoques, en la siguiente imagen se muestran algunos ejemplos: Podemos pensar en una infinidad de aplicaciones comerciales basadas en el análisis de datos. Con la intención de estructurar las posibles aplicaciones, se ofrece a continuación una categorización que, aunque no es suficiente para englobar todos los posibles casos de uso, sí es sorprendente la cantidad de aplicaciones que abarca. 1. Aplicaciones centradas en los clientes Incrementar beneficio al mejorar recomendaciones de productos Up-selling Cross-selling Reducir tasas de cancelación y mejorar tasas de retención Personalizar experiencia de usuario Mejorar el marketing dirigido Análisis de sentimientos Personalización de productos o servicios 2. Optimización de problemas Optimización de precios Ubicación de nuevas sucursales Maximización de ganancias mediante producción de materias primas Construcción de portafolios de inversión 3. Predicción de demanda Número futuro de clientes Número esperado de viajes en avión / camión / bicis Número de contagios por un virus (demanda médica / medicamentos / etc) Predicción de uso de recursos (luz / agua / gas) 4. Análisis de detección de fraudes Detección de robo de identidad Detección de transacciones ilícitas Detección de servicios fraudulentos Detección de zonas geográficas con actividades ilícitas "],["introducción-a-r.html", "Capítulo 2 Introducción a R 2.1 ¿Cómo obtener R? 2.2 ¿Qué es RStudio? 2.3 Lectura de datos 2.4 Tidyverse", " Capítulo 2 Introducción a R R (R Core Team) es un entorno y lenguaje de programación que permite el análisis estadístico de información y reportes gráficos. Es ampliamente usado en investigación por la comunidad estadística en campos como la biomedicina, minería de datos, matemáticas financieras, entre otros. Ha ganado mucha popularidad en los últimos años al ser un software libre que está en constante crecimiento por las aportaciones de otros usuarios y que permite la interacción con software estadísticos como STATA, SAS, SPSS, etc.. R permite la incorporación de librerías y paqueterías con funcionalidades específicas, por lo que es un lenguaje de programación muy completo y fácil de usar. 2.1 ¿Cómo obtener R? R puede ser fácilmente descargado de forma gratuita desde el sitio oficial http://www.r-project.org/. R está disponible para las plataformas Windows, Mac y Linux. 2.2 ¿Qué es RStudio? RStudio es un Entorno de Desarrollo Integrado (IDE, por sus siglas en inglés) para R. Este permite y facilita el desarrollo y ejecución de sintaxis para código en R, incluye una consola y proporciona herramientas para la gestión del espacio de trabajo. RStudio está disponible para Windows, Mac y Linux o para navegadores conectados a RStudio Server o RStudio Server Pro. Algunas de las principales características de Rstudio que lo hacen una gran herramienta para trabajar en R, son: Auto completado de código Sangría inteligente Resaltado de sintaxis Facilidad para definir funciones Soporte integrado Documentación integrada Administración de directorios y proyectos Visor de datos Depurador interactivo para corregir errores Conección con Rmarkwon y Sweave La siguiente imagen muestra la forma en la que está estructurado RStudio. El orden de los páneles puede ser elegido por el usuario, así como las características de tipo de letra, tamaño y color de fondo, entre otras características. Figure 2.1: Páneles de trabajo de Rstudio 2.3 Lectura de datos El primer paso para analizar datos es incorporarlos a la sesión de R para que puedan ser manipulados y observados. Existen múltiples librerías y funciones en R que permiten leer la información proveniente de un archivo externo, el cual puede tener una de muchas posibles extensiones. Usualmente, no creamos los datos desde la sesión de R, sino que a través de un archivo externo se realiza la lectura de datos escritos en un archivo. Los más comúnes son: La paquetería readr fue desarrollada recientemente para lidiar con la lectura de archivos grandes rápidamente. Esta paquetería proporciona funciones que suelen ser mucho más rápidas que las funciones base que proporciona R. Ventajas de readr: Por lo general, son mucho más rápidos (~ 10x) que sus funciones equivalentes. Producen tibbles: No convierten vectores de caracteres en factores. No usan nombres de filas ni modifican los nombres de columnas. Reproducibilidad 2.3.1 Archivos csv A la hora de importar conjuntos de datos en R, uno de los formatos más habituales en los que hallamos información es en archivos separados por comas (comma separated values), cuya extensión suele ser .csv. En ellos encontramos múltiples líneas que recogen la tabla de interés, y en las cuales los valores aparecen, de manera consecutiva, separados por el carácter ,. Para importar este tipo de archivos en nuestra sesión de R, se utiliza la función read_csv(). Para acceder a su documentación utilizamos el comando ?read_csv. El único argumento que debemos de pasar a esta función de manera obligatoria, es file, el nombre o la ruta completa del archivo que pretendemos importar. library(readr) library(dplyr) Algunas de las ventajas de utilizar read_csv() son: No convierte, automáticamente, las columnas con cadenas de caracteres a factores, como sí hacen por defecto las otras funciones base de R. Reconoce ocho clases diferentes de datos (enteros, lógicos, etc.), dejando el resto como cadenas de caracteres. Veamos un ejemplo: La tabla de datos llamada proyecto_ames_train contiene un conjunto de datos con información del precio de venta de casas y sus respectivas características. tidy &lt;- read_csv(&quot;data/proyecto_ames_train.csv&quot;) glimpse(tidy) ## Rows: 1,393 ## Columns: 80 ## $ `MS SubClass` &lt;dbl&gt; 60, 85, 90, 20, 20, 60, 20, 20, 60, 70, 20, 20, 20, … ## $ `MS Zoning` &lt;chr&gt; &quot;RL&quot;, &quot;RL&quot;, &quot;RL&quot;, &quot;RL&quot;, &quot;RL&quot;, &quot;RL&quot;, &quot;RL&quot;, &quot;RL&quot;, &quot;RL&quot;… ## $ `Lot Frontage` &lt;dbl&gt; 60, 66, 74, 65, NA, 46, 60, 80, 63, 60, NA, NA, 66, … ## $ `Lot Area` &lt;dbl&gt; 17433, 6760, 6882, 8769, 17600, 20544, 10950, 13384,… ## $ Street &lt;chr&gt; &quot;Pave&quot;, &quot;Pave&quot;, &quot;Pave&quot;, &quot;Pave&quot;, &quot;Pave&quot;, &quot;Pave&quot;, &quot;Pav… ## $ Alley &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ `Lot Shape` &lt;chr&gt; &quot;IR2&quot;, &quot;Reg&quot;, &quot;Reg&quot;, &quot;Reg&quot;, &quot;IR1&quot;, &quot;IR1&quot;, &quot;Reg&quot;, &quot;Re… ## $ `Land Contour` &lt;chr&gt; &quot;Lvl&quot;, &quot;Lvl&quot;, &quot;Lvl&quot;, &quot;Lvl&quot;, &quot;Lvl&quot;, &quot;Lvl&quot;, &quot;Lvl&quot;, &quot;Lv… ## $ Utilities &lt;chr&gt; &quot;AllPub&quot;, &quot;AllPub&quot;, &quot;AllPub&quot;, &quot;AllPub&quot;, &quot;AllPub&quot;, &quot;A… ## $ `Lot Config` &lt;chr&gt; &quot;CulDSac&quot;, &quot;Inside&quot;, &quot;Corner&quot;, &quot;FR2&quot;, &quot;Inside&quot;, &quot;Cul… ## $ `Land Slope` &lt;chr&gt; &quot;Gtl&quot;, &quot;Gtl&quot;, &quot;Gtl&quot;, &quot;Gtl&quot;, &quot;Gtl&quot;, &quot;Gtl&quot;, &quot;Gtl&quot;, &quot;Mo… ## $ Neighborhood &lt;chr&gt; &quot;NoRidge&quot;, &quot;NAmes&quot;, &quot;Edwards&quot;, &quot;CollgCr&quot;, &quot;NAmes&quot;, &quot;… ## $ `Condition 1` &lt;chr&gt; &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;Nor… ## $ `Condition 2` &lt;chr&gt; &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;Norm&quot;, &quot;Nor… ## $ `Bldg Type` &lt;chr&gt; &quot;1Fam&quot;, &quot;1Fam&quot;, &quot;Duplex&quot;, &quot;1Fam&quot;, &quot;1Fam&quot;, &quot;1Fam&quot;, &quot;1… ## $ `House Style` &lt;chr&gt; &quot;2Story&quot;, &quot;SFoyer&quot;, &quot;1Story&quot;, &quot;1Story&quot;, &quot;1Story&quot;, &quot;2… ## $ `Overall Qual` &lt;dbl&gt; 8, 5, 4, 7, 6, 7, 6, 5, 7, 7, 6, 5, 8, 5, 6, 7, 5, 7… ## $ `Overall Cond` &lt;dbl&gt; 5, 5, 3, 5, 5, 6, 6, 5, 5, 7, 2, 6, 5, 8, 6, 5, 5, 7… ## $ `Year Built` &lt;dbl&gt; 1998, 1962, 1955, 2005, 1960, 1986, 1952, 1969, 1998… ## $ `Year Remod/Add` &lt;dbl&gt; 1998, 1962, 1955, 2005, 1960, 1991, 1952, 1979, 1998… ## $ `Roof Style` &lt;chr&gt; &quot;Hip&quot;, &quot;Gable&quot;, &quot;Gable&quot;, &quot;Gable&quot;, &quot;Gable&quot;, &quot;Gable&quot;, … ## $ `Roof Matl` &lt;chr&gt; &quot;CompShg&quot;, &quot;CompShg&quot;, &quot;CompShg&quot;, &quot;CompShg&quot;, &quot;CompShg… ## $ `Exterior 1st` &lt;chr&gt; &quot;VinylSd&quot;, &quot;HdBoard&quot;, &quot;AsbShng&quot;, &quot;VinylSd&quot;, &quot;Wd Sdng… ## $ `Exterior 2nd` &lt;chr&gt; &quot;VinylSd&quot;, &quot;HdBoard&quot;, &quot;Plywood&quot;, &quot;VinylSd&quot;, &quot;Wd Sdng… ## $ `Mas Vnr Type` &lt;chr&gt; &quot;BrkFace&quot;, &quot;None&quot;, &quot;BrkCmn&quot;, &quot;None&quot;, &quot;BrkFace&quot;, &quot;Brk… ## $ `Mas Vnr Area` &lt;dbl&gt; 114, 0, 128, 0, 30, 123, 0, 194, 0, 0, 0, 0, 306, 0,… ## $ `Exter Qual` &lt;chr&gt; &quot;Gd&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;Gd&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;… ## $ `Exter Cond` &lt;chr&gt; &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;Gd&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;… ## $ Foundation &lt;chr&gt; &quot;PConc&quot;, &quot;CBlock&quot;, &quot;PConc&quot;, &quot;PConc&quot;, &quot;CBlock&quot;, &quot;CBlo… ## $ `Bsmt Qual` &lt;chr&gt; &quot;Ex&quot;, &quot;TA&quot;, NA, &quot;Gd&quot;, &quot;TA&quot;, &quot;Gd&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;Gd&quot;, … ## $ `Bsmt Cond` &lt;chr&gt; &quot;TA&quot;, &quot;TA&quot;, NA, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, … ## $ `Bsmt Exposure` &lt;chr&gt; &quot;No&quot;, &quot;Av&quot;, NA, &quot;Av&quot;, &quot;No&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Av&quot;, &quot;No&quot;, … ## $ `BsmtFin Type 1` &lt;chr&gt; &quot;Unf&quot;, &quot;ALQ&quot;, NA, &quot;GLQ&quot;, &quot;BLQ&quot;, &quot;Unf&quot;, &quot;ALQ&quot;, &quot;Rec&quot;,… ## $ `BsmtFin SF 1` &lt;dbl&gt; 0, 734, 0, 709, 1270, 0, 441, 119, 0, 0, 0, 660, 0, … ## $ `BsmtFin Type 2` &lt;chr&gt; &quot;Unf&quot;, &quot;Unf&quot;, NA, &quot;Unf&quot;, &quot;Unf&quot;, &quot;Unf&quot;, &quot;Unf&quot;, &quot;BLQ&quot;,… ## $ `BsmtFin SF 2` &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 344, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ `Bsmt Unf SF` &lt;dbl&gt; 1629, 162, 0, 460, 208, 791, 507, 641, 935, 1313, 16… ## $ `Total Bsmt SF` &lt;dbl&gt; 1629, 896, 0, 1169, 1478, 791, 948, 1104, 935, 1313,… ## $ Heating &lt;chr&gt; &quot;GasA&quot;, &quot;GasA&quot;, &quot;GasA&quot;, &quot;GasA&quot;, &quot;GasA&quot;, &quot;GasA&quot;, &quot;Gas… ## $ `Heating QC` &lt;chr&gt; &quot;Ex&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;Ex&quot;, &quot;Ex&quot;, &quot;Gd&quot;, &quot;TA&quot;, &quot;Fa&quot;, &quot;Gd&quot;… ## $ `Central Air` &lt;chr&gt; &quot;Y&quot;, &quot;Y&quot;, &quot;N&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y… ## $ Electrical &lt;chr&gt; &quot;SBrkr&quot;, &quot;SBrkr&quot;, &quot;SBrkr&quot;, &quot;SBrkr&quot;, &quot;FuseA&quot;, &quot;SBrkr&quot;… ## $ `1st Flr SF` &lt;dbl&gt; 1645, 936, 1152, 1190, 1478, 1236, 948, 1360, 955, 1… ## $ `2nd Flr SF` &lt;dbl&gt; 830, 0, 0, 0, 0, 857, 0, 0, 677, 1182, 0, 0, 0, 0, 9… ## $ `Low Qual Fin SF` &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ `Gr Liv Area` &lt;dbl&gt; 2475, 936, 1152, 1190, 1478, 2093, 948, 1360, 1632, … ## $ `Bsmt Full Bath` &lt;dbl&gt; 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1… ## $ `Bsmt Half Bath` &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ `Full Bath` &lt;dbl&gt; 2, 1, 2, 2, 2, 2, 1, 1, 2, 2, 1, 1, 2, 1, 2, 2, 2, 2… ## $ `Half Bath` &lt;dbl&gt; 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1… ## $ `Bedroom AbvGr` &lt;dbl&gt; 4, 3, 2, 2, 3, 3, 2, 3, 3, 5, 3, 3, 3, 2, 4, 3, 3, 3… ## $ `Kitchen AbvGr` &lt;dbl&gt; 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1… ## $ `Kitchen Qual` &lt;chr&gt; &quot;Gd&quot;, &quot;TA&quot;, &quot;Fa&quot;, &quot;Gd&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;… ## $ `TotRms AbvGrd` &lt;dbl&gt; 7, 6, 6, 5, 6, 7, 5, 8, 8, 10, 7, 5, 7, 4, 8, 6, 6, … ## $ Functional &lt;chr&gt; &quot;Typ&quot;, &quot;Typ&quot;, &quot;Typ&quot;, &quot;Typ&quot;, &quot;Typ&quot;, &quot;Typ&quot;, &quot;Typ&quot;, &quot;Ty… ## $ Fireplaces &lt;dbl&gt; 1, 1, 0, 0, 2, 1, 0, 1, 1, 1, 2, 0, 1, 0, 0, 0, 1, 2… ## $ `Fireplace Qu` &lt;chr&gt; &quot;TA&quot;, &quot;Po&quot;, NA, NA, &quot;Gd&quot;, &quot;TA&quot;, NA, &quot;TA&quot;, &quot;TA&quot;, &quot;Gd&quot;… ## $ `Garage Type` &lt;chr&gt; &quot;Attchd&quot;, &quot;Attchd&quot;, NA, &quot;Attchd&quot;, &quot;Attchd&quot;, &quot;Attchd&quot;… ## $ `Garage Yr Blt` &lt;dbl&gt; 1998, 1962, NA, 2005, 1960, 1986, 1952, 1969, 1998, … ## $ `Garage Finish` &lt;chr&gt; &quot;Fin&quot;, &quot;RFn&quot;, NA, &quot;RFn&quot;, &quot;Unf&quot;, &quot;Fin&quot;, &quot;Unf&quot;, &quot;RFn&quot;,… ## $ `Garage Cars` &lt;dbl&gt; 3, 1, 0, 2, 2, 2, 2, 1, 2, 2, 2, 2, 3, 1, 2, 2, 2, 2… ## $ `Garage Area` &lt;dbl&gt; 962, 288, 0, 578, 498, 542, 410, 336, 462, 342, 495,… ## $ `Garage Qual` &lt;chr&gt; &quot;TA&quot;, &quot;TA&quot;, NA, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, … ## $ `Garage Cond` &lt;chr&gt; &quot;TA&quot;, &quot;TA&quot;, NA, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, &quot;TA&quot;, … ## $ `Paved Drive` &lt;chr&gt; &quot;Y&quot;, &quot;Y&quot;, &quot;N&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;N&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y… ## $ `Wood Deck SF` &lt;dbl&gt; 23, 24, 0, 100, 0, 364, 0, 160, 0, 0, 0, 0, 192, 144… ## $ `Open Porch SF` &lt;dbl&gt; 172, 90, 0, 41, 40, 63, 48, 0, 28, 299, 0, 312, 64, … ## $ `Enclosed Porch` &lt;dbl&gt; 0, 160, 0, 0, 0, 0, 0, 0, 0, 0, 144, 0, 0, 80, 0, 0,… ## $ `3Ssn Porch` &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ `Screen Porch` &lt;dbl&gt; 256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,… ## $ `Pool Area` &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0… ## $ `Pool QC` &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, … ## $ Fence &lt;chr&gt; NA, NA, NA, NA, NA, &quot;MnPrv&quot;, NA, NA, NA, NA, NA, NA,… ## $ `Misc Feature` &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, &quot;Shed&quot;, NA, … ## $ `Misc Val` &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 750, 0, 0, 0, 0, 0, 0,… ## $ `Mo Sold` &lt;dbl&gt; 1, 10, 9, 10, 12, 11, 4, 5, 6, 12, 5, 6, 9, 12, 8, 5… ## $ `Yr Sold` &lt;dbl&gt; 2010, 2007, 2007, 2007, 2009, 2008, 2007, 2006, 2006… ## $ `Sale Type` &lt;chr&gt; &quot;WD&quot;, &quot;WD&quot;, &quot;WD&quot;, &quot;WD&quot;, &quot;WD&quot;, &quot;WD&quot;, &quot;WD&quot;, &quot;WD&quot;, &quot;WD&quot;… ## $ `Sale Condition` &lt;chr&gt; &quot;Normal&quot;, &quot;Normal&quot;, &quot;Normal&quot;, &quot;Normal&quot;, &quot;Normal&quot;, &quot;N… ## $ SalePrice &lt;dbl&gt; 355000, 130000, 61500, 173500, 157500, 215000, 12500… ¿Y si el archivo que necesitamos leer esta en excel? 2.3.2 Archivos xls y xlsx La paquetería readxl facilita la obtención de datos tabulares de archivos de Excel. Admite tanto el formato .xls heredado como el formato .xlsx moderno basado en XML. Esta paqueteía pone a disposición las siguientes funciones: read_xlsx() lee un archivo con extensión xlsx. read_excel() determina si el archivo es de tipo xls o xlsx para después llamar a una de las fuciones mencionadas anteriormente. EJERCICIO: Leer archivos propios en formato de Excel 2.4 Tidyverse Ahora que ya sabemos como cargar datos, aprenderemos como manipularlos con dplyr. El paquete dplyr proporciona un conjunto de funciones muy útiles para manipular data frames y así reducir el número de repeticiones, la probabilidad de cometer errores y el número de caracteres que hay que escribir. Como valor extra, podemos encontrar que la gramática de dplyr es más fácil de entender. Revisaremos algunas de sus funciones más usadas (verbos), así como el uso de pipes (%&gt;%) para combinarlas. select() filter() arrange() mutate() summarise() join() group_by() Primero tenemos que instalar y cargar la paquetería (parte de tidyverse): library(dplyr) Usaremos el dataset iris que se encuentra en la paquetería datasets (el alumno puede hacer el ejercicio con la tabla de su elección) head(iris,10) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa 2.4.1 select() Observamos que nuestros datos tienen 150 observaciones y 5 variables, con select() podemos seleccionar las variables que le indiquemos. select_ejemplo&lt;-iris %&gt;% select(Sepal.Length,Petal.Length,Species) head(select_ejemplo,10) ## Sepal.Length Petal.Length Species ## 1 5.1 1.4 setosa ## 2 4.9 1.4 setosa ## 3 4.7 1.3 setosa ## 4 4.6 1.5 setosa ## 5 5.0 1.4 setosa ## 6 5.4 1.7 setosa ## 7 4.6 1.4 setosa ## 8 5.0 1.5 setosa ## 9 4.4 1.4 setosa ## 10 4.9 1.5 setosa ¡¡ RECORDAR !! El operador pipe (%&gt;%) se usa para conectar múltiples acciones En este caso solo le indicamos que en los datos de iris se seleccionan 3 varibles y se guarda este nuevo data frame en la variable select_ejemplo. Con select() y contains podemos seleccionar varibles con alguna cadena de texto. select_ejemplo &lt;- iris %&gt;% select(contains(&quot;Sepal&quot;)) head(select_ejemplo, 5) ## Sepal.Length Sepal.Width ## 1 5.1 3.5 ## 2 4.9 3.0 ## 3 4.7 3.2 ## 4 4.6 3.1 ## 5 5.0 3.6 De igual manera, con select(), ends_with y start_with() podemos seleccionar que inicien o terminen con alguna cadena de texto. select_ejemplo &lt;- iris %&gt;% select(starts_with(&quot;Sepal&quot;), ends_with(&quot;Length&quot;)) head(select_ejemplo, 5) ## Sepal.Length Sepal.Width Petal.Length ## 1 5.1 3.5 1.4 ## 2 4.9 3.0 1.4 ## 3 4.7 3.2 1.3 ## 4 4.6 3.1 1.5 ## 5 5.0 3.6 1.4 Funciones útiles para select(): contains(): Selecciona variables cuyo nombre contiene la cadena de texto. ends_with(): Selecciona variables cuyo nombre termina con la cadena de caracteres. everything(): Selecciona todas las columnas. matches(): Selecciona las variables cuyos nombres coinciden con una expresión regular. num_range(): Selecciona las variables por posición. start_with(): Selecciona variables cuyos nombres empiezan con la cadena de caracteres. any_of: Selecciona cualquiera de estas variables, en caso de existir 2.4.2 filter() La función filter nos permite filtrar filas según una condición, primero notemos que la variable Species tiene tres categorías. iris %&gt;% count(Species) ## Species n ## 1 setosa 50 ## 2 versicolor 50 ## 3 virginica 50 Ahora usaremos la función filter para quedarnos solo con las observaciones de la especie virginica. ejemplo_filter &lt;- iris %&gt;% filter(Species==&quot;virginica&quot;) head(ejemplo_filter, 5) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 6.3 3.3 6.0 2.5 virginica ## 2 5.8 2.7 5.1 1.9 virginica ## 3 7.1 3.0 5.9 2.1 virginica ## 4 6.3 2.9 5.6 1.8 virginica ## 5 6.5 3.0 5.8 2.2 virginica También se puede usar para filtrar variables numéricas: ejemplo_filter&lt;- iris %&gt;% filter(Sepal.Length &gt; 5 &amp; Sepal.Width &gt;= 3.5) head(ejemplo_filter, 5) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 5.4 3.9 1.7 0.4 setosa ## 3 5.4 3.7 1.5 0.2 setosa ## 4 5.8 4.0 1.2 0.2 setosa ## 5 5.7 4.4 1.5 0.4 setosa Notemos que en el ejemplo anterior usamos &amp;, que nos ayuda a filtrar por dos condiciones. También podemos usar | para filtrar por alguna de las dos condiciones. ejemplo_filter&lt;- iris %&gt;% filter(Sepal.Length&gt;5 | Sepal.Width&gt;=3.5) head(ejemplo_filter,5) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 5.0 3.6 1.4 0.2 setosa ## 3 5.4 3.9 1.7 0.4 setosa ## 4 5.4 3.7 1.5 0.2 setosa ## 5 5.8 4.0 1.2 0.2 setosa Las condiciones pueden ser expresiones lógicas construidas mediante los operadores relacionales y lógicos: &lt; : Menor que &gt; : Mayor que = : Igual que &lt;= : Menor o igual que &gt;= : Mayor o igual que != : Diferente que %in% : Pertenece al conjunto is.na : Es NA !is.na : No es NA 2.4.3 arrange() La función arrange() se utiliza para ordenar las filas de un data frame de acuerdo a una o varias variables. Por defecto arrange() ordena las filas por orden ascendente: ejemplo_arrange &lt;- iris %&gt;% arrange(Sepal.Length) head(ejemplo_arrange, 10) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 4.3 3.0 1.1 0.1 setosa ## 2 4.4 2.9 1.4 0.2 setosa ## 3 4.4 3.0 1.3 0.2 setosa ## 4 4.4 3.2 1.3 0.2 setosa ## 5 4.5 2.3 1.3 0.3 setosa ## 6 4.6 3.1 1.5 0.2 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 4.6 3.6 1.0 0.2 setosa ## 9 4.6 3.2 1.4 0.2 setosa ## 10 4.7 3.2 1.3 0.2 setosa Si las queremos ordenar de forma ascendente lo haremos del siguiente modo: ejemplo_arrange &lt;- iris %&gt;% arrange(desc(Sepal.Length)) head(ejemplo_arrange, 10) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 7.9 3.8 6.4 2.0 virginica ## 2 7.7 3.8 6.7 2.2 virginica ## 3 7.7 2.6 6.9 2.3 virginica ## 4 7.7 2.8 6.7 2.0 virginica ## 5 7.7 3.0 6.1 2.3 virginica ## 6 7.6 3.0 6.6 2.1 virginica ## 7 7.4 2.8 6.1 1.9 virginica ## 8 7.3 2.9 6.3 1.8 virginica ## 9 7.2 3.6 6.1 2.5 virginica ## 10 7.2 3.2 6.0 1.8 virginica 2.4.4 mutate() Con la función mutate() podemos computar tranformaciones de variables en un data frame. A menudo, tendremos la necesidad de crear nuevas variables que se calculan a partir de variables existentes,mutate() nos proporciona una interface clara para realizar este tipo de operaciones. Por ejemplo haremos la suma de las variables Sepal.Lenght y Sepal.Width: ejemplo_mutate &lt;- iris %&gt;% select(Sepal.Length, Sepal.Width) %&gt;% mutate(Suma = Sepal.Length + Sepal.Width) head(ejemplo_mutate, 5) ## Sepal.Length Sepal.Width Suma ## 1 5.1 3.5 8.6 ## 2 4.9 3.0 7.9 ## 3 4.7 3.2 7.9 ## 4 4.6 3.1 7.7 ## 5 5.0 3.6 8.6 ¡¡ RECORDAR !! Notemos que en el ejemplo anterior usamos dos pipes (%&gt;%). Como habiamos mencionado se pueden usar los pipes necesarios para combinar tareas. 2.4.5 summarise() La función summarise() funciona de forma análoga a la función mutate, excepto que en lugar de añadir nuevas columnas crea un nuevo data frame. Podemos usar el ejemplo anterior y calcular la media de la varible creada Suma: ejemplo_summarise &lt;- iris %&gt;% select(Sepal.Length, Sepal.Width) %&gt;% mutate(Suma = Sepal.Length + Sepal.Width) %&gt;% summarise(Media_Suma = mean(Suma)) ejemplo_summarise ## Media_Suma ## 1 8.900667 Solo fue necesario agregar un pipe, especificar el nombre de la varible creada y la operación a realizar. A continuación se muestran funciones que trabajando conjuntamente con la función summarise() facilitarán nuestro trabajo diario. Las primeras pertenecen al paquete base y las otras son del paquete dplyr. Todas ellas toman como argumento un vector y devuelven un único resultado: min(), max() : Valores max y min. mean() : Media. median() : Mediana. sum() : Suma de los valores. var(), sd() : Varianza y desviación estandar. first() : Primer valor en un vector. last() : El último valor en un vector n() : El número de valores en un vector. n_distinc() : El número de valores distintos en un vector. nth() : Extrar el valor que ocupa la posición n en un vector. Mas adelante veremos como combinar esta función con la función group_by. 2.4.6 group_by() La función group_by() agrupa un conjunto de filas seleccionado en un conjunto de filas de resumen de acuerdo con los valores de una o más columnas o expresiones. Usaremos el ejemplo anterior, primero creamos nuestra nueva variable Suma, despues agrupamos por especie y al final sacamos la media de la variable Suma pero esta vez, por la función group_by, nos regresara una media por cada grupo creado, es decir, nos regresara el promedio de la suma por especie. ejemplo_groupby &lt;- iris %&gt;% mutate(Suma = Sepal.Length + Sepal.Width) %&gt;% group_by(Species) %&gt;% summarise(Media_Suma = mean(Suma)) ejemplo_groupby ## # A tibble: 3 × 2 ## Species Media_Suma ## &lt;fct&gt; &lt;dbl&gt; ## 1 setosa 8.43 ## 2 versicolor 8.71 ## 3 virginica 9.56 2.4.7 left_join() Una operación fundamental por agregar a nuestro flujo de trabajo es el cruce de tablas, las cuales pueden proceder de la misma o de distinta fuente. Comúnmente este proceso se realiza para enriquecer y unificar la información proveniente de distintas tablas de datos. Para lograr esta tarea es indispensable que exista una variable llave en ambos conjuntos de datos que sirva como puente o identificador de cada caso o renglón. Si se cuenta con la columna llave entonces será posible cruzar las tablas y lograr su enriquecimiento. En el siguiente ejemplo se muestra el uso de la variable llave a través de la columna “ID”. Se puede apreciar que en la tabla final se cuenta con información de la variable “Weight” para los elementos que existen en las tablas “A” y “B”. La función que hace posible el complemento de la información es llamada left_join(). El primer argumento de la función corresponde al conjunto de datos que se desea complementar, mientras que en el segundo argumento se ingresa el conjunto de datos con la información que enriquecerá al primer conjunto. Es necesario especificar en el argumento “by” el nombre de la columna llave. conjuntoX &lt;- data.frame(&quot;Llave&quot; = LETTERS[1:8], &quot;C1&quot; = 1:8) conjuntoY &lt;- data.frame( &quot;Llave&quot; = sample(LETTERS[11:3], size = 9, replace = T), &quot;Ex1&quot; = letters[2:10], &quot;Ex2&quot; = 1002:1010, &quot;Ex3&quot; = paste0(letters[12:20],2:10) ) conjuntoX ## Llave C1 ## 1 A 1 ## 2 B 2 ## 3 C 3 ## 4 D 4 ## 5 E 5 ## 6 F 6 ## 7 G 7 ## 8 H 8 conjuntoY ## Llave Ex1 Ex2 Ex3 ## 1 K b 1002 l2 ## 2 K c 1003 m3 ## 3 K d 1004 n4 ## 4 C e 1005 o5 ## 5 I f 1006 p6 ## 6 H g 1007 q7 ## 7 D h 1008 r8 ## 8 I i 1009 s9 ## 9 J j 1010 t10 left_join(x = conjuntoX, y = conjuntoY, by = &quot;Llave&quot;) ## Llave C1 Ex1 Ex2 Ex3 ## 1 A 1 &lt;NA&gt; NA &lt;NA&gt; ## 2 B 2 &lt;NA&gt; NA &lt;NA&gt; ## 3 C 3 e 1005 o5 ## 4 D 4 h 1008 r8 ## 5 E 5 &lt;NA&gt; NA &lt;NA&gt; ## 6 F 6 &lt;NA&gt; NA &lt;NA&gt; ## 7 G 7 &lt;NA&gt; NA &lt;NA&gt; ## 8 H 8 g 1007 q7 Es posible que no todas las observaciones de un conjunto de datos estén en el otro conjunto, cuando esto sucede un aviso aparece indicando que los factores o categorías de la variable llave son diferentes. En caso de no encontrarse uno o más de los valores, el resultado para esos casos será NA (no disponible, por su traducción del inglés “Not Available”), y aparecerá siempre que no se cuente con información en un registro, como se muestra en el ejemplo anterior. "]]
